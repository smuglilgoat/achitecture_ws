// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com/here/pb/hdmap/shared/v1/core/conditional-attributes.proto

#ifndef PROTOBUF_INCLUDED_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto
#define PROTOBUF_INCLUDED_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "com/here/pb/hdmap/shared/v1/core/common.pb.h"
#include "com/here/pb/hdmap/shared/v1/core/conditional-attribute-modifiers.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto();
namespace com {
namespace here {
namespace pb {
namespace hdmap {
namespace shared {
namespace v1 {
namespace core {
class ConditionalAccessPermission;
class ConditionalAccessPermissionDefaultTypeInternal;
extern ConditionalAccessPermissionDefaultTypeInternal _ConditionalAccessPermission_default_instance_;
class ConditionalAccessRestriction;
class ConditionalAccessRestrictionDefaultTypeInternal;
extern ConditionalAccessRestrictionDefaultTypeInternal _ConditionalAccessRestriction_default_instance_;
class ConditionalOvertakingRestriction;
class ConditionalOvertakingRestrictionDefaultTypeInternal;
extern ConditionalOvertakingRestrictionDefaultTypeInternal _ConditionalOvertakingRestriction_default_instance_;
class ConditionalPermittedDrivingManoeuvre;
class ConditionalPermittedDrivingManoeuvreDefaultTypeInternal;
extern ConditionalPermittedDrivingManoeuvreDefaultTypeInternal _ConditionalPermittedDrivingManoeuvre_default_instance_;
class ConditionalRestrictedDrivingManoeuvre;
class ConditionalRestrictedDrivingManoeuvreDefaultTypeInternal;
extern ConditionalRestrictedDrivingManoeuvreDefaultTypeInternal _ConditionalRestrictedDrivingManoeuvre_default_instance_;
class ConditionalSpeedLimit;
class ConditionalSpeedLimitDefaultTypeInternal;
extern ConditionalSpeedLimitDefaultTypeInternal _ConditionalSpeedLimit_default_instance_;
class ConditionalSpeedLimit_Advisory;
class ConditionalSpeedLimit_AdvisoryDefaultTypeInternal;
extern ConditionalSpeedLimit_AdvisoryDefaultTypeInternal _ConditionalSpeedLimit_Advisory_default_instance_;
class ConditionalSpeedLimit_Environmental;
class ConditionalSpeedLimit_EnvironmentalDefaultTypeInternal;
extern ConditionalSpeedLimit_EnvironmentalDefaultTypeInternal _ConditionalSpeedLimit_Environmental_default_instance_;
class ConditionalSpeedLimit_LaneDependent;
class ConditionalSpeedLimit_LaneDependentDefaultTypeInternal;
extern ConditionalSpeedLimit_LaneDependentDefaultTypeInternal _ConditionalSpeedLimit_LaneDependent_default_instance_;
class ConditionalSpeedLimit_LocationProximity;
class ConditionalSpeedLimit_LocationProximityDefaultTypeInternal;
extern ConditionalSpeedLimit_LocationProximityDefaultTypeInternal _ConditionalSpeedLimit_LocationProximity_default_instance_;
class ConditionalSpeedLimit_TimeDependent;
class ConditionalSpeedLimit_TimeDependentDefaultTypeInternal;
extern ConditionalSpeedLimit_TimeDependentDefaultTypeInternal _ConditionalSpeedLimit_TimeDependent_default_instance_;
class ConditionalSpeedLimit_TrafficCalmingMeasures;
class ConditionalSpeedLimit_TrafficCalmingMeasuresDefaultTypeInternal;
extern ConditionalSpeedLimit_TrafficCalmingMeasuresDefaultTypeInternal _ConditionalSpeedLimit_TrafficCalmingMeasures_default_instance_;
class ConditionalTollStructure;
class ConditionalTollStructureDefaultTypeInternal;
extern ConditionalTollStructureDefaultTypeInternal _ConditionalTollStructure_default_instance_;
class ConditionalUsageFeeRequired;
class ConditionalUsageFeeRequiredDefaultTypeInternal;
extern ConditionalUsageFeeRequiredDefaultTypeInternal _ConditionalUsageFeeRequired_default_instance_;
}  // namespace core
}  // namespace v1
}  // namespace shared
}  // namespace hdmap
}  // namespace pb
}  // namespace here
}  // namespace com
namespace google {
namespace protobuf {
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessPermission* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalAccessPermission>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace com {
namespace here {
namespace pb {
namespace hdmap {
namespace shared {
namespace v1 {
namespace core {

enum ConditionalOvertakingRestriction_WeatherType {
  ConditionalOvertakingRestriction_WeatherType_WeatherType_UNKNOWN = 0,
  ConditionalOvertakingRestriction_WeatherType_RAIN = 1,
  ConditionalOvertakingRestriction_WeatherType_SNOW = 2,
  ConditionalOvertakingRestriction_WeatherType_FOG = 3,
  ConditionalOvertakingRestriction_WeatherType_NOT_APPLICABLE = 4,
  ConditionalOvertakingRestriction_WeatherType_ConditionalOvertakingRestriction_WeatherType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalOvertakingRestriction_WeatherType_ConditionalOvertakingRestriction_WeatherType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalOvertakingRestriction_WeatherType_IsValid(int value);
const ConditionalOvertakingRestriction_WeatherType ConditionalOvertakingRestriction_WeatherType_WeatherType_MIN = ConditionalOvertakingRestriction_WeatherType_WeatherType_UNKNOWN;
const ConditionalOvertakingRestriction_WeatherType ConditionalOvertakingRestriction_WeatherType_WeatherType_MAX = ConditionalOvertakingRestriction_WeatherType_NOT_APPLICABLE;
const int ConditionalOvertakingRestriction_WeatherType_WeatherType_ARRAYSIZE = ConditionalOvertakingRestriction_WeatherType_WeatherType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalOvertakingRestriction_WeatherType_descriptor();
inline const ::std::string& ConditionalOvertakingRestriction_WeatherType_Name(ConditionalOvertakingRestriction_WeatherType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalOvertakingRestriction_WeatherType_descriptor(), value);
}
inline bool ConditionalOvertakingRestriction_WeatherType_Parse(
    const ::std::string& name, ConditionalOvertakingRestriction_WeatherType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalOvertakingRestriction_WeatherType>(
    ConditionalOvertakingRestriction_WeatherType_descriptor(), name, value);
}
enum ConditionalUsageFeeRequired_TollFeatureType {
  ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_UNKNOWN = 0,
  ConditionalUsageFeeRequired_TollFeatureType_TOLL_ROAD = 1,
  ConditionalUsageFeeRequired_TollFeatureType_BRIDGE = 2,
  ConditionalUsageFeeRequired_TollFeatureType_TUNNEL = 3,
  ConditionalUsageFeeRequired_TollFeatureType_PARK = 4,
  ConditionalUsageFeeRequired_TollFeatureType_MOUNTAIN_PASS = 5,
  ConditionalUsageFeeRequired_TollFeatureType_SCENIC_ROUTE = 6,
  ConditionalUsageFeeRequired_TollFeatureType_VIGNETTE_ROAD = 7,
  ConditionalUsageFeeRequired_TollFeatureType_TOLL_ZONE = 8,
  ConditionalUsageFeeRequired_TollFeatureType_ConditionalUsageFeeRequired_TollFeatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalUsageFeeRequired_TollFeatureType_ConditionalUsageFeeRequired_TollFeatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalUsageFeeRequired_TollFeatureType_IsValid(int value);
const ConditionalUsageFeeRequired_TollFeatureType ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_MIN = ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_UNKNOWN;
const ConditionalUsageFeeRequired_TollFeatureType ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_MAX = ConditionalUsageFeeRequired_TollFeatureType_TOLL_ZONE;
const int ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_ARRAYSIZE = ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalUsageFeeRequired_TollFeatureType_descriptor();
inline const ::std::string& ConditionalUsageFeeRequired_TollFeatureType_Name(ConditionalUsageFeeRequired_TollFeatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalUsageFeeRequired_TollFeatureType_descriptor(), value);
}
inline bool ConditionalUsageFeeRequired_TollFeatureType_Parse(
    const ::std::string& name, ConditionalUsageFeeRequired_TollFeatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalUsageFeeRequired_TollFeatureType>(
    ConditionalUsageFeeRequired_TollFeatureType_descriptor(), name, value);
}
enum ConditionalRestrictedDrivingManoeuvre_RestrictionType {
  ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_NONE = 0,
  ConditionalRestrictedDrivingManoeuvre_RestrictionType_LEGAL = 1,
  ConditionalRestrictedDrivingManoeuvre_RestrictionType_PHYSICAL = 2,
  ConditionalRestrictedDrivingManoeuvre_RestrictionType_LOGICAL = 3,
  ConditionalRestrictedDrivingManoeuvre_RestrictionType_ConditionalRestrictedDrivingManoeuvre_RestrictionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalRestrictedDrivingManoeuvre_RestrictionType_ConditionalRestrictedDrivingManoeuvre_RestrictionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalRestrictedDrivingManoeuvre_RestrictionType_IsValid(int value);
const ConditionalRestrictedDrivingManoeuvre_RestrictionType ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_MIN = ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_NONE;
const ConditionalRestrictedDrivingManoeuvre_RestrictionType ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_MAX = ConditionalRestrictedDrivingManoeuvre_RestrictionType_LOGICAL;
const int ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_ARRAYSIZE = ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalRestrictedDrivingManoeuvre_RestrictionType_descriptor();
inline const ::std::string& ConditionalRestrictedDrivingManoeuvre_RestrictionType_Name(ConditionalRestrictedDrivingManoeuvre_RestrictionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_descriptor(), value);
}
inline bool ConditionalRestrictedDrivingManoeuvre_RestrictionType_Parse(
    const ::std::string& name, ConditionalRestrictedDrivingManoeuvre_RestrictionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalRestrictedDrivingManoeuvre_RestrictionType>(
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_descriptor(), name, value);
}
enum ConditionalPermittedDrivingManoeuvre_PermissionType {
  ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_UNKNOWN = 0,
  ConditionalPermittedDrivingManoeuvre_PermissionType_LEGAL = 1,
  ConditionalPermittedDrivingManoeuvre_PermissionType_ConditionalPermittedDrivingManoeuvre_PermissionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalPermittedDrivingManoeuvre_PermissionType_ConditionalPermittedDrivingManoeuvre_PermissionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalPermittedDrivingManoeuvre_PermissionType_IsValid(int value);
const ConditionalPermittedDrivingManoeuvre_PermissionType ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_MIN = ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_UNKNOWN;
const ConditionalPermittedDrivingManoeuvre_PermissionType ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_MAX = ConditionalPermittedDrivingManoeuvre_PermissionType_LEGAL;
const int ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_ARRAYSIZE = ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalPermittedDrivingManoeuvre_PermissionType_descriptor();
inline const ::std::string& ConditionalPermittedDrivingManoeuvre_PermissionType_Name(ConditionalPermittedDrivingManoeuvre_PermissionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalPermittedDrivingManoeuvre_PermissionType_descriptor(), value);
}
inline bool ConditionalPermittedDrivingManoeuvre_PermissionType_Parse(
    const ::std::string& name, ConditionalPermittedDrivingManoeuvre_PermissionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalPermittedDrivingManoeuvre_PermissionType>(
    ConditionalPermittedDrivingManoeuvre_PermissionType_descriptor(), name, value);
}
enum ConditionalAccessRestriction_DependentAccessType {
  ConditionalAccessRestriction_DependentAccessType_DependentAccessType_UNKNOWN = 0,
  ConditionalAccessRestriction_DependentAccessType_VARIABLE = 1,
  ConditionalAccessRestriction_DependentAccessType_ConditionalAccessRestriction_DependentAccessType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalAccessRestriction_DependentAccessType_ConditionalAccessRestriction_DependentAccessType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalAccessRestriction_DependentAccessType_IsValid(int value);
const ConditionalAccessRestriction_DependentAccessType ConditionalAccessRestriction_DependentAccessType_DependentAccessType_MIN = ConditionalAccessRestriction_DependentAccessType_DependentAccessType_UNKNOWN;
const ConditionalAccessRestriction_DependentAccessType ConditionalAccessRestriction_DependentAccessType_DependentAccessType_MAX = ConditionalAccessRestriction_DependentAccessType_VARIABLE;
const int ConditionalAccessRestriction_DependentAccessType_DependentAccessType_ARRAYSIZE = ConditionalAccessRestriction_DependentAccessType_DependentAccessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalAccessRestriction_DependentAccessType_descriptor();
inline const ::std::string& ConditionalAccessRestriction_DependentAccessType_Name(ConditionalAccessRestriction_DependentAccessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalAccessRestriction_DependentAccessType_descriptor(), value);
}
inline bool ConditionalAccessRestriction_DependentAccessType_Parse(
    const ::std::string& name, ConditionalAccessRestriction_DependentAccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalAccessRestriction_DependentAccessType>(
    ConditionalAccessRestriction_DependentAccessType_descriptor(), name, value);
}
enum ConditionalSpeedLimit_LocationProximity_LocationProximityType {
  ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_UNKNOWN = 0,
  ConditionalSpeedLimit_LocationProximity_LocationProximityType_SCHOOL = 1,
  ConditionalSpeedLimit_LocationProximity_LocationProximityType_ConditionalSpeedLimit_LocationProximity_LocationProximityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalSpeedLimit_LocationProximity_LocationProximityType_ConditionalSpeedLimit_LocationProximity_LocationProximityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalSpeedLimit_LocationProximity_LocationProximityType_IsValid(int value);
const ConditionalSpeedLimit_LocationProximity_LocationProximityType ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_MIN = ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_UNKNOWN;
const ConditionalSpeedLimit_LocationProximity_LocationProximityType ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_MAX = ConditionalSpeedLimit_LocationProximity_LocationProximityType_SCHOOL;
const int ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_ARRAYSIZE = ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalSpeedLimit_LocationProximity_LocationProximityType_descriptor();
inline const ::std::string& ConditionalSpeedLimit_LocationProximity_LocationProximityType_Name(ConditionalSpeedLimit_LocationProximity_LocationProximityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_descriptor(), value);
}
inline bool ConditionalSpeedLimit_LocationProximity_LocationProximityType_Parse(
    const ::std::string& name, ConditionalSpeedLimit_LocationProximity_LocationProximityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalSpeedLimit_LocationProximity_LocationProximityType>(
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_descriptor(), name, value);
}
enum ConditionalSpeedLimit_Environmental_EnvironmentalType {
  ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_UNKNOWN = 0,
  ConditionalSpeedLimit_Environmental_EnvironmentalType_FOG = 1,
  ConditionalSpeedLimit_Environmental_EnvironmentalType_RAIN = 2,
  ConditionalSpeedLimit_Environmental_EnvironmentalType_SNOW = 3,
  ConditionalSpeedLimit_Environmental_EnvironmentalType_ConditionalSpeedLimit_Environmental_EnvironmentalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalSpeedLimit_Environmental_EnvironmentalType_ConditionalSpeedLimit_Environmental_EnvironmentalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalSpeedLimit_Environmental_EnvironmentalType_IsValid(int value);
const ConditionalSpeedLimit_Environmental_EnvironmentalType ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_MIN = ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_UNKNOWN;
const ConditionalSpeedLimit_Environmental_EnvironmentalType ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_MAX = ConditionalSpeedLimit_Environmental_EnvironmentalType_SNOW;
const int ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_ARRAYSIZE = ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalSpeedLimit_Environmental_EnvironmentalType_descriptor();
inline const ::std::string& ConditionalSpeedLimit_Environmental_EnvironmentalType_Name(ConditionalSpeedLimit_Environmental_EnvironmentalType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalSpeedLimit_Environmental_EnvironmentalType_descriptor(), value);
}
inline bool ConditionalSpeedLimit_Environmental_EnvironmentalType_Parse(
    const ::std::string& name, ConditionalSpeedLimit_Environmental_EnvironmentalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalSpeedLimit_Environmental_EnvironmentalType>(
    ConditionalSpeedLimit_Environmental_EnvironmentalType_descriptor(), name, value);
}
enum ConditionalTollStructure_TollStructureType {
  ConditionalTollStructure_TollStructureType_TollStructureType_UNKNOWN = 0,
  ConditionalTollStructure_TollStructureType_FIXED_FEE = 1,
  ConditionalTollStructure_TollStructureType_OBTAIN_TICKET = 2,
  ConditionalTollStructure_TollStructureType_PAY_PER_TICKET = 3,
  ConditionalTollStructure_TollStructureType_ELECTRONIC = 4,
  ConditionalTollStructure_TollStructureType_ConditionalTollStructure_TollStructureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalTollStructure_TollStructureType_ConditionalTollStructure_TollStructureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalTollStructure_TollStructureType_IsValid(int value);
const ConditionalTollStructure_TollStructureType ConditionalTollStructure_TollStructureType_TollStructureType_MIN = ConditionalTollStructure_TollStructureType_TollStructureType_UNKNOWN;
const ConditionalTollStructure_TollStructureType ConditionalTollStructure_TollStructureType_TollStructureType_MAX = ConditionalTollStructure_TollStructureType_ELECTRONIC;
const int ConditionalTollStructure_TollStructureType_TollStructureType_ARRAYSIZE = ConditionalTollStructure_TollStructureType_TollStructureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalTollStructure_TollStructureType_descriptor();
inline const ::std::string& ConditionalTollStructure_TollStructureType_Name(ConditionalTollStructure_TollStructureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalTollStructure_TollStructureType_descriptor(), value);
}
inline bool ConditionalTollStructure_TollStructureType_Parse(
    const ::std::string& name, ConditionalTollStructure_TollStructureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalTollStructure_TollStructureType>(
    ConditionalTollStructure_TollStructureType_descriptor(), name, value);
}
enum ConditionalTollStructure_TollPaymentMethod {
  ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_UNKNOWN = 0,
  ConditionalTollStructure_TollPaymentMethod_CASH = 1,
  ConditionalTollStructure_TollPaymentMethod_BANK_CARD = 2,
  ConditionalTollStructure_TollPaymentMethod_CREDIT_CARD = 3,
  ConditionalTollStructure_TollPaymentMethod_PASS_OR_SUBSCRIPTION = 4,
  ConditionalTollStructure_TollPaymentMethod_TRANSPONDER = 5,
  ConditionalTollStructure_TollPaymentMethod_VIDEO_TOLL_CHARGE = 6,
  ConditionalTollStructure_TollPaymentMethod_EXACT_CASH = 7,
  ConditionalTollStructure_TollPaymentMethod_TRAVEL_CARD = 8,
  ConditionalTollStructure_TollPaymentMethod_ConditionalTollStructure_TollPaymentMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConditionalTollStructure_TollPaymentMethod_ConditionalTollStructure_TollPaymentMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConditionalTollStructure_TollPaymentMethod_IsValid(int value);
const ConditionalTollStructure_TollPaymentMethod ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_MIN = ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_UNKNOWN;
const ConditionalTollStructure_TollPaymentMethod ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_MAX = ConditionalTollStructure_TollPaymentMethod_TRAVEL_CARD;
const int ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_ARRAYSIZE = ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionalTollStructure_TollPaymentMethod_descriptor();
inline const ::std::string& ConditionalTollStructure_TollPaymentMethod_Name(ConditionalTollStructure_TollPaymentMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionalTollStructure_TollPaymentMethod_descriptor(), value);
}
inline bool ConditionalTollStructure_TollPaymentMethod_Parse(
    const ::std::string& name, ConditionalTollStructure_TollPaymentMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionalTollStructure_TollPaymentMethod>(
    ConditionalTollStructure_TollPaymentMethod_descriptor(), name, value);
}
// ===================================================================

class ConditionalOvertakingRestriction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction) */ {
 public:
  ConditionalOvertakingRestriction();
  virtual ~ConditionalOvertakingRestriction();

  ConditionalOvertakingRestriction(const ConditionalOvertakingRestriction& from);

  inline ConditionalOvertakingRestriction& operator=(const ConditionalOvertakingRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalOvertakingRestriction(ConditionalOvertakingRestriction&& from) noexcept
    : ConditionalOvertakingRestriction() {
    *this = ::std::move(from);
  }

  inline ConditionalOvertakingRestriction& operator=(ConditionalOvertakingRestriction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalOvertakingRestriction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalOvertakingRestriction* internal_default_instance() {
    return reinterpret_cast<const ConditionalOvertakingRestriction*>(
               &_ConditionalOvertakingRestriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ConditionalOvertakingRestriction* other);
  friend void swap(ConditionalOvertakingRestriction& a, ConditionalOvertakingRestriction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalOvertakingRestriction* New() const final {
    return CreateMaybeMessage<ConditionalOvertakingRestriction>(nullptr);
  }

  ConditionalOvertakingRestriction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalOvertakingRestriction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalOvertakingRestriction& from);
  void MergeFrom(const ConditionalOvertakingRestriction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalOvertakingRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalOvertakingRestriction_WeatherType WeatherType;
  static const WeatherType WeatherType_UNKNOWN =
    ConditionalOvertakingRestriction_WeatherType_WeatherType_UNKNOWN;
  static const WeatherType RAIN =
    ConditionalOvertakingRestriction_WeatherType_RAIN;
  static const WeatherType SNOW =
    ConditionalOvertakingRestriction_WeatherType_SNOW;
  static const WeatherType FOG =
    ConditionalOvertakingRestriction_WeatherType_FOG;
  static const WeatherType NOT_APPLICABLE =
    ConditionalOvertakingRestriction_WeatherType_NOT_APPLICABLE;
  static inline bool WeatherType_IsValid(int value) {
    return ConditionalOvertakingRestriction_WeatherType_IsValid(value);
  }
  static const WeatherType WeatherType_MIN =
    ConditionalOvertakingRestriction_WeatherType_WeatherType_MIN;
  static const WeatherType WeatherType_MAX =
    ConditionalOvertakingRestriction_WeatherType_WeatherType_MAX;
  static const int WeatherType_ARRAYSIZE =
    ConditionalOvertakingRestriction_WeatherType_WeatherType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WeatherType_descriptor() {
    return ConditionalOvertakingRestriction_WeatherType_descriptor();
  }
  static inline const ::std::string& WeatherType_Name(WeatherType value) {
    return ConditionalOvertakingRestriction_WeatherType_Name(value);
  }
  static inline bool WeatherType_Parse(const ::std::string& name,
      WeatherType* value) {
    return ConditionalOvertakingRestriction_WeatherType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
  int applies_during_size() const;
  void clear_applies_during();
  static const int kAppliesDuringFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_applies_during(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_applies_during();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& applies_during(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_applies_during();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      applies_during() const;

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.WeatherType applies_in_weather_conditions = 3;
  void clear_applies_in_weather_conditions();
  static const int kAppliesInWeatherConditionsFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType applies_in_weather_conditions() const;
  void set_applies_in_weather_conditions(::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > applies_during_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  int applies_in_weather_conditions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalUsageFeeRequired final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired) */ {
 public:
  ConditionalUsageFeeRequired();
  virtual ~ConditionalUsageFeeRequired();

  ConditionalUsageFeeRequired(const ConditionalUsageFeeRequired& from);

  inline ConditionalUsageFeeRequired& operator=(const ConditionalUsageFeeRequired& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalUsageFeeRequired(ConditionalUsageFeeRequired&& from) noexcept
    : ConditionalUsageFeeRequired() {
    *this = ::std::move(from);
  }

  inline ConditionalUsageFeeRequired& operator=(ConditionalUsageFeeRequired&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalUsageFeeRequired& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalUsageFeeRequired* internal_default_instance() {
    return reinterpret_cast<const ConditionalUsageFeeRequired*>(
               &_ConditionalUsageFeeRequired_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ConditionalUsageFeeRequired* other);
  friend void swap(ConditionalUsageFeeRequired& a, ConditionalUsageFeeRequired& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalUsageFeeRequired* New() const final {
    return CreateMaybeMessage<ConditionalUsageFeeRequired>(nullptr);
  }

  ConditionalUsageFeeRequired* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalUsageFeeRequired>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalUsageFeeRequired& from);
  void MergeFrom(const ConditionalUsageFeeRequired& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalUsageFeeRequired* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalUsageFeeRequired_TollFeatureType TollFeatureType;
  static const TollFeatureType TollFeatureType_UNKNOWN =
    ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_UNKNOWN;
  static const TollFeatureType TOLL_ROAD =
    ConditionalUsageFeeRequired_TollFeatureType_TOLL_ROAD;
  static const TollFeatureType BRIDGE =
    ConditionalUsageFeeRequired_TollFeatureType_BRIDGE;
  static const TollFeatureType TUNNEL =
    ConditionalUsageFeeRequired_TollFeatureType_TUNNEL;
  static const TollFeatureType PARK =
    ConditionalUsageFeeRequired_TollFeatureType_PARK;
  static const TollFeatureType MOUNTAIN_PASS =
    ConditionalUsageFeeRequired_TollFeatureType_MOUNTAIN_PASS;
  static const TollFeatureType SCENIC_ROUTE =
    ConditionalUsageFeeRequired_TollFeatureType_SCENIC_ROUTE;
  static const TollFeatureType VIGNETTE_ROAD =
    ConditionalUsageFeeRequired_TollFeatureType_VIGNETTE_ROAD;
  static const TollFeatureType TOLL_ZONE =
    ConditionalUsageFeeRequired_TollFeatureType_TOLL_ZONE;
  static inline bool TollFeatureType_IsValid(int value) {
    return ConditionalUsageFeeRequired_TollFeatureType_IsValid(value);
  }
  static const TollFeatureType TollFeatureType_MIN =
    ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_MIN;
  static const TollFeatureType TollFeatureType_MAX =
    ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_MAX;
  static const int TollFeatureType_ARRAYSIZE =
    ConditionalUsageFeeRequired_TollFeatureType_TollFeatureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TollFeatureType_descriptor() {
    return ConditionalUsageFeeRequired_TollFeatureType_descriptor();
  }
  static inline const ::std::string& TollFeatureType_Name(TollFeatureType value) {
    return ConditionalUsageFeeRequired_TollFeatureType_Name(value);
  }
  static inline bool TollFeatureType_Parse(const ::std::string& name,
      TollFeatureType* value) {
    return ConditionalUsageFeeRequired_TollFeatureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
  int applies_during_size() const;
  void clear_applies_during();
  static const int kAppliesDuringFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_applies_during(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_applies_during();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& applies_during(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_applies_during();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      applies_during() const;

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.TollFeatureType toll_feature_type = 3;
  void clear_toll_feature_type();
  static const int kTollFeatureTypeFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType toll_feature_type() const;
  void set_toll_feature_type(::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > applies_during_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  int toll_feature_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalRestrictedDrivingManoeuvre final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre) */ {
 public:
  ConditionalRestrictedDrivingManoeuvre();
  virtual ~ConditionalRestrictedDrivingManoeuvre();

  ConditionalRestrictedDrivingManoeuvre(const ConditionalRestrictedDrivingManoeuvre& from);

  inline ConditionalRestrictedDrivingManoeuvre& operator=(const ConditionalRestrictedDrivingManoeuvre& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalRestrictedDrivingManoeuvre(ConditionalRestrictedDrivingManoeuvre&& from) noexcept
    : ConditionalRestrictedDrivingManoeuvre() {
    *this = ::std::move(from);
  }

  inline ConditionalRestrictedDrivingManoeuvre& operator=(ConditionalRestrictedDrivingManoeuvre&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalRestrictedDrivingManoeuvre& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalRestrictedDrivingManoeuvre* internal_default_instance() {
    return reinterpret_cast<const ConditionalRestrictedDrivingManoeuvre*>(
               &_ConditionalRestrictedDrivingManoeuvre_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ConditionalRestrictedDrivingManoeuvre* other);
  friend void swap(ConditionalRestrictedDrivingManoeuvre& a, ConditionalRestrictedDrivingManoeuvre& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalRestrictedDrivingManoeuvre* New() const final {
    return CreateMaybeMessage<ConditionalRestrictedDrivingManoeuvre>(nullptr);
  }

  ConditionalRestrictedDrivingManoeuvre* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalRestrictedDrivingManoeuvre>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalRestrictedDrivingManoeuvre& from);
  void MergeFrom(const ConditionalRestrictedDrivingManoeuvre& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalRestrictedDrivingManoeuvre* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalRestrictedDrivingManoeuvre_RestrictionType RestrictionType;
  static const RestrictionType RestrictionType_NONE =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_NONE;
  static const RestrictionType LEGAL =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_LEGAL;
  static const RestrictionType PHYSICAL =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_PHYSICAL;
  static const RestrictionType LOGICAL =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_LOGICAL;
  static inline bool RestrictionType_IsValid(int value) {
    return ConditionalRestrictedDrivingManoeuvre_RestrictionType_IsValid(value);
  }
  static const RestrictionType RestrictionType_MIN =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_MIN;
  static const RestrictionType RestrictionType_MAX =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_MAX;
  static const int RestrictionType_ARRAYSIZE =
    ConditionalRestrictedDrivingManoeuvre_RestrictionType_RestrictionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RestrictionType_descriptor() {
    return ConditionalRestrictedDrivingManoeuvre_RestrictionType_descriptor();
  }
  static inline const ::std::string& RestrictionType_Name(RestrictionType value) {
    return ConditionalRestrictedDrivingManoeuvre_RestrictionType_Name(value);
  }
  static inline bool RestrictionType_Parse(const ::std::string& name,
      RestrictionType* value) {
    return ConditionalRestrictedDrivingManoeuvre_RestrictionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
  int applies_during_size() const;
  void clear_applies_during();
  static const int kAppliesDuringFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_applies_during(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_applies_during();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& applies_during(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_applies_during();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      applies_during() const;

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.RestrictionType restriction_type = 3;
  void clear_restriction_type();
  static const int kRestrictionTypeFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType restriction_type() const;
  void set_restriction_type(::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > applies_during_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  int restriction_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalPermittedDrivingManoeuvre final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre) */ {
 public:
  ConditionalPermittedDrivingManoeuvre();
  virtual ~ConditionalPermittedDrivingManoeuvre();

  ConditionalPermittedDrivingManoeuvre(const ConditionalPermittedDrivingManoeuvre& from);

  inline ConditionalPermittedDrivingManoeuvre& operator=(const ConditionalPermittedDrivingManoeuvre& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalPermittedDrivingManoeuvre(ConditionalPermittedDrivingManoeuvre&& from) noexcept
    : ConditionalPermittedDrivingManoeuvre() {
    *this = ::std::move(from);
  }

  inline ConditionalPermittedDrivingManoeuvre& operator=(ConditionalPermittedDrivingManoeuvre&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalPermittedDrivingManoeuvre& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalPermittedDrivingManoeuvre* internal_default_instance() {
    return reinterpret_cast<const ConditionalPermittedDrivingManoeuvre*>(
               &_ConditionalPermittedDrivingManoeuvre_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ConditionalPermittedDrivingManoeuvre* other);
  friend void swap(ConditionalPermittedDrivingManoeuvre& a, ConditionalPermittedDrivingManoeuvre& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalPermittedDrivingManoeuvre* New() const final {
    return CreateMaybeMessage<ConditionalPermittedDrivingManoeuvre>(nullptr);
  }

  ConditionalPermittedDrivingManoeuvre* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalPermittedDrivingManoeuvre>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalPermittedDrivingManoeuvre& from);
  void MergeFrom(const ConditionalPermittedDrivingManoeuvre& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalPermittedDrivingManoeuvre* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalPermittedDrivingManoeuvre_PermissionType PermissionType;
  static const PermissionType PermissionType_UNKNOWN =
    ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_UNKNOWN;
  static const PermissionType LEGAL =
    ConditionalPermittedDrivingManoeuvre_PermissionType_LEGAL;
  static inline bool PermissionType_IsValid(int value) {
    return ConditionalPermittedDrivingManoeuvre_PermissionType_IsValid(value);
  }
  static const PermissionType PermissionType_MIN =
    ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_MIN;
  static const PermissionType PermissionType_MAX =
    ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_MAX;
  static const int PermissionType_ARRAYSIZE =
    ConditionalPermittedDrivingManoeuvre_PermissionType_PermissionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PermissionType_descriptor() {
    return ConditionalPermittedDrivingManoeuvre_PermissionType_descriptor();
  }
  static inline const ::std::string& PermissionType_Name(PermissionType value) {
    return ConditionalPermittedDrivingManoeuvre_PermissionType_Name(value);
  }
  static inline bool PermissionType_Parse(const ::std::string& name,
      PermissionType* value) {
    return ConditionalPermittedDrivingManoeuvre_PermissionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
  int applies_during_size() const;
  void clear_applies_during();
  static const int kAppliesDuringFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_applies_during(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_applies_during();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& applies_during(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_applies_during();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      applies_during() const;

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.PermissionType permission_type = 3;
  void clear_permission_type();
  static const int kPermissionTypeFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType permission_type() const;
  void set_permission_type(::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > applies_during_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  int permission_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalAccessRestriction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction) */ {
 public:
  ConditionalAccessRestriction();
  virtual ~ConditionalAccessRestriction();

  ConditionalAccessRestriction(const ConditionalAccessRestriction& from);

  inline ConditionalAccessRestriction& operator=(const ConditionalAccessRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalAccessRestriction(ConditionalAccessRestriction&& from) noexcept
    : ConditionalAccessRestriction() {
    *this = ::std::move(from);
  }

  inline ConditionalAccessRestriction& operator=(ConditionalAccessRestriction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalAccessRestriction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalAccessRestriction* internal_default_instance() {
    return reinterpret_cast<const ConditionalAccessRestriction*>(
               &_ConditionalAccessRestriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ConditionalAccessRestriction* other);
  friend void swap(ConditionalAccessRestriction& a, ConditionalAccessRestriction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalAccessRestriction* New() const final {
    return CreateMaybeMessage<ConditionalAccessRestriction>(nullptr);
  }

  ConditionalAccessRestriction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalAccessRestriction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalAccessRestriction& from);
  void MergeFrom(const ConditionalAccessRestriction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalAccessRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalAccessRestriction_DependentAccessType DependentAccessType;
  static const DependentAccessType DependentAccessType_UNKNOWN =
    ConditionalAccessRestriction_DependentAccessType_DependentAccessType_UNKNOWN;
  static const DependentAccessType VARIABLE =
    ConditionalAccessRestriction_DependentAccessType_VARIABLE;
  static inline bool DependentAccessType_IsValid(int value) {
    return ConditionalAccessRestriction_DependentAccessType_IsValid(value);
  }
  static const DependentAccessType DependentAccessType_MIN =
    ConditionalAccessRestriction_DependentAccessType_DependentAccessType_MIN;
  static const DependentAccessType DependentAccessType_MAX =
    ConditionalAccessRestriction_DependentAccessType_DependentAccessType_MAX;
  static const int DependentAccessType_ARRAYSIZE =
    ConditionalAccessRestriction_DependentAccessType_DependentAccessType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DependentAccessType_descriptor() {
    return ConditionalAccessRestriction_DependentAccessType_descriptor();
  }
  static inline const ::std::string& DependentAccessType_Name(DependentAccessType value) {
    return ConditionalAccessRestriction_DependentAccessType_Name(value);
  }
  static inline bool DependentAccessType_Parse(const ::std::string& name,
      DependentAccessType* value) {
    return ConditionalAccessRestriction_DependentAccessType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
  int applies_during_size() const;
  void clear_applies_during();
  static const int kAppliesDuringFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_applies_during(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_applies_during();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& applies_during(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_applies_during();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      applies_during() const;

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.DependentAccessType dependent_access_type = 3;
  void clear_dependent_access_type();
  static const int kDependentAccessTypeFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType dependent_access_type() const;
  void set_dependent_access_type(::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > applies_during_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  int dependent_access_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalAccessPermission final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission) */ {
 public:
  ConditionalAccessPermission();
  virtual ~ConditionalAccessPermission();

  ConditionalAccessPermission(const ConditionalAccessPermission& from);

  inline ConditionalAccessPermission& operator=(const ConditionalAccessPermission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalAccessPermission(ConditionalAccessPermission&& from) noexcept
    : ConditionalAccessPermission() {
    *this = ::std::move(from);
  }

  inline ConditionalAccessPermission& operator=(ConditionalAccessPermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalAccessPermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalAccessPermission* internal_default_instance() {
    return reinterpret_cast<const ConditionalAccessPermission*>(
               &_ConditionalAccessPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ConditionalAccessPermission* other);
  friend void swap(ConditionalAccessPermission& a, ConditionalAccessPermission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalAccessPermission* New() const final {
    return CreateMaybeMessage<ConditionalAccessPermission>(nullptr);
  }

  ConditionalAccessPermission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalAccessPermission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalAccessPermission& from);
  void MergeFrom(const ConditionalAccessPermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalAccessPermission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
  int applies_during_size() const;
  void clear_applies_during();
  static const int kAppliesDuringFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_applies_during(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_applies_during();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& applies_during(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_applies_during();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      applies_during() const;

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > applies_during_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit_Advisory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory) */ {
 public:
  ConditionalSpeedLimit_Advisory();
  virtual ~ConditionalSpeedLimit_Advisory();

  ConditionalSpeedLimit_Advisory(const ConditionalSpeedLimit_Advisory& from);

  inline ConditionalSpeedLimit_Advisory& operator=(const ConditionalSpeedLimit_Advisory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit_Advisory(ConditionalSpeedLimit_Advisory&& from) noexcept
    : ConditionalSpeedLimit_Advisory() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit_Advisory& operator=(ConditionalSpeedLimit_Advisory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit_Advisory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit_Advisory* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit_Advisory*>(
               &_ConditionalSpeedLimit_Advisory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ConditionalSpeedLimit_Advisory* other);
  friend void swap(ConditionalSpeedLimit_Advisory& a, ConditionalSpeedLimit_Advisory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit_Advisory* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_Advisory>(nullptr);
  }

  ConditionalSpeedLimit_Advisory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_Advisory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit_Advisory& from);
  void MergeFrom(const ConditionalSpeedLimit_Advisory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit_Advisory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .com.here.pb.hdmap.shared.v1.core.SpeedLimit override_speed_limit = 1;
  bool has_override_speed_limit() const;
  void clear_override_speed_limit();
  static const int kOverrideSpeedLimitFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& override_speed_limit() const;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* release_override_speed_limit();
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* mutable_override_speed_limit();
  void set_allocated_override_speed_limit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit_TrafficCalmingMeasures final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TrafficCalmingMeasures) */ {
 public:
  ConditionalSpeedLimit_TrafficCalmingMeasures();
  virtual ~ConditionalSpeedLimit_TrafficCalmingMeasures();

  ConditionalSpeedLimit_TrafficCalmingMeasures(const ConditionalSpeedLimit_TrafficCalmingMeasures& from);

  inline ConditionalSpeedLimit_TrafficCalmingMeasures& operator=(const ConditionalSpeedLimit_TrafficCalmingMeasures& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit_TrafficCalmingMeasures(ConditionalSpeedLimit_TrafficCalmingMeasures&& from) noexcept
    : ConditionalSpeedLimit_TrafficCalmingMeasures() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit_TrafficCalmingMeasures& operator=(ConditionalSpeedLimit_TrafficCalmingMeasures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit_TrafficCalmingMeasures& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit_TrafficCalmingMeasures* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit_TrafficCalmingMeasures*>(
               &_ConditionalSpeedLimit_TrafficCalmingMeasures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ConditionalSpeedLimit_TrafficCalmingMeasures* other);
  friend void swap(ConditionalSpeedLimit_TrafficCalmingMeasures& a, ConditionalSpeedLimit_TrafficCalmingMeasures& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit_TrafficCalmingMeasures* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_TrafficCalmingMeasures>(nullptr);
  }

  ConditionalSpeedLimit_TrafficCalmingMeasures* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_TrafficCalmingMeasures>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit_TrafficCalmingMeasures& from);
  void MergeFrom(const ConditionalSpeedLimit_TrafficCalmingMeasures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit_TrafficCalmingMeasures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TrafficCalmingMeasures)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit_LocationProximity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity) */ {
 public:
  ConditionalSpeedLimit_LocationProximity();
  virtual ~ConditionalSpeedLimit_LocationProximity();

  ConditionalSpeedLimit_LocationProximity(const ConditionalSpeedLimit_LocationProximity& from);

  inline ConditionalSpeedLimit_LocationProximity& operator=(const ConditionalSpeedLimit_LocationProximity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit_LocationProximity(ConditionalSpeedLimit_LocationProximity&& from) noexcept
    : ConditionalSpeedLimit_LocationProximity() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit_LocationProximity& operator=(ConditionalSpeedLimit_LocationProximity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit_LocationProximity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit_LocationProximity* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit_LocationProximity*>(
               &_ConditionalSpeedLimit_LocationProximity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ConditionalSpeedLimit_LocationProximity* other);
  friend void swap(ConditionalSpeedLimit_LocationProximity& a, ConditionalSpeedLimit_LocationProximity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit_LocationProximity* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_LocationProximity>(nullptr);
  }

  ConditionalSpeedLimit_LocationProximity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_LocationProximity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit_LocationProximity& from);
  void MergeFrom(const ConditionalSpeedLimit_LocationProximity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit_LocationProximity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalSpeedLimit_LocationProximity_LocationProximityType LocationProximityType;
  static const LocationProximityType LocationProximityType_UNKNOWN =
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_UNKNOWN;
  static const LocationProximityType SCHOOL =
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_SCHOOL;
  static inline bool LocationProximityType_IsValid(int value) {
    return ConditionalSpeedLimit_LocationProximity_LocationProximityType_IsValid(value);
  }
  static const LocationProximityType LocationProximityType_MIN =
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_MIN;
  static const LocationProximityType LocationProximityType_MAX =
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_MAX;
  static const int LocationProximityType_ARRAYSIZE =
    ConditionalSpeedLimit_LocationProximity_LocationProximityType_LocationProximityType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LocationProximityType_descriptor() {
    return ConditionalSpeedLimit_LocationProximity_LocationProximityType_descriptor();
  }
  static inline const ::std::string& LocationProximityType_Name(LocationProximityType value) {
    return ConditionalSpeedLimit_LocationProximity_LocationProximityType_Name(value);
  }
  static inline bool LocationProximityType_Parse(const ::std::string& name,
      LocationProximityType* value) {
    return ConditionalSpeedLimit_LocationProximity_LocationProximityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier during_date_time = 2;
  int during_date_time_size() const;
  void clear_during_date_time();
  static const int kDuringDateTimeFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_during_date_time(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_during_date_time();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& during_date_time(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_during_date_time();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      during_date_time() const;

  // .com.here.pb.hdmap.shared.v1.core.SpeedLimit overrideSpeedLimit = 1;
  bool has_overridespeedlimit() const;
  void clear_overridespeedlimit();
  static const int kOverrideSpeedLimitFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& overridespeedlimit() const;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* release_overridespeedlimit();
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* mutable_overridespeedlimit();
  void set_allocated_overridespeedlimit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* overridespeedlimit);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.LocationProximityType location_proximity_type = 3;
  void clear_location_proximity_type();
  static const int kLocationProximityTypeFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType location_proximity_type() const;
  void set_location_proximity_type(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > during_date_time_;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* overridespeedlimit_;
  int location_proximity_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit_Environmental final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental) */ {
 public:
  ConditionalSpeedLimit_Environmental();
  virtual ~ConditionalSpeedLimit_Environmental();

  ConditionalSpeedLimit_Environmental(const ConditionalSpeedLimit_Environmental& from);

  inline ConditionalSpeedLimit_Environmental& operator=(const ConditionalSpeedLimit_Environmental& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit_Environmental(ConditionalSpeedLimit_Environmental&& from) noexcept
    : ConditionalSpeedLimit_Environmental() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit_Environmental& operator=(ConditionalSpeedLimit_Environmental&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit_Environmental& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit_Environmental* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit_Environmental*>(
               &_ConditionalSpeedLimit_Environmental_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ConditionalSpeedLimit_Environmental* other);
  friend void swap(ConditionalSpeedLimit_Environmental& a, ConditionalSpeedLimit_Environmental& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit_Environmental* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_Environmental>(nullptr);
  }

  ConditionalSpeedLimit_Environmental* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_Environmental>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit_Environmental& from);
  void MergeFrom(const ConditionalSpeedLimit_Environmental& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit_Environmental* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalSpeedLimit_Environmental_EnvironmentalType EnvironmentalType;
  static const EnvironmentalType EnvironmentalType_UNKNOWN =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_UNKNOWN;
  static const EnvironmentalType FOG =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_FOG;
  static const EnvironmentalType RAIN =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_RAIN;
  static const EnvironmentalType SNOW =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_SNOW;
  static inline bool EnvironmentalType_IsValid(int value) {
    return ConditionalSpeedLimit_Environmental_EnvironmentalType_IsValid(value);
  }
  static const EnvironmentalType EnvironmentalType_MIN =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_MIN;
  static const EnvironmentalType EnvironmentalType_MAX =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_MAX;
  static const int EnvironmentalType_ARRAYSIZE =
    ConditionalSpeedLimit_Environmental_EnvironmentalType_EnvironmentalType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EnvironmentalType_descriptor() {
    return ConditionalSpeedLimit_Environmental_EnvironmentalType_descriptor();
  }
  static inline const ::std::string& EnvironmentalType_Name(EnvironmentalType value) {
    return ConditionalSpeedLimit_Environmental_EnvironmentalType_Name(value);
  }
  static inline bool EnvironmentalType_Parse(const ::std::string& name,
      EnvironmentalType* value) {
    return ConditionalSpeedLimit_Environmental_EnvironmentalType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .com.here.pb.hdmap.shared.v1.core.SpeedLimit override_speed_limit = 1;
  bool has_override_speed_limit() const;
  void clear_override_speed_limit();
  static const int kOverrideSpeedLimitFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& override_speed_limit() const;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* release_override_speed_limit();
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* mutable_override_speed_limit();
  void set_allocated_override_speed_limit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.EnvironmentalType environmental_type = 2;
  void clear_environmental_type();
  static const int kEnvironmentalTypeFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType environmental_type() const;
  void set_environmental_type(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit_;
  int environmental_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit_TimeDependent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent) */ {
 public:
  ConditionalSpeedLimit_TimeDependent();
  virtual ~ConditionalSpeedLimit_TimeDependent();

  ConditionalSpeedLimit_TimeDependent(const ConditionalSpeedLimit_TimeDependent& from);

  inline ConditionalSpeedLimit_TimeDependent& operator=(const ConditionalSpeedLimit_TimeDependent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit_TimeDependent(ConditionalSpeedLimit_TimeDependent&& from) noexcept
    : ConditionalSpeedLimit_TimeDependent() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit_TimeDependent& operator=(ConditionalSpeedLimit_TimeDependent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit_TimeDependent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit_TimeDependent* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit_TimeDependent*>(
               &_ConditionalSpeedLimit_TimeDependent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ConditionalSpeedLimit_TimeDependent* other);
  friend void swap(ConditionalSpeedLimit_TimeDependent& a, ConditionalSpeedLimit_TimeDependent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit_TimeDependent* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_TimeDependent>(nullptr);
  }

  ConditionalSpeedLimit_TimeDependent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_TimeDependent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit_TimeDependent& from);
  void MergeFrom(const ConditionalSpeedLimit_TimeDependent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit_TimeDependent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier during_date_time = 2;
  int during_date_time_size() const;
  void clear_during_date_time();
  static const int kDuringDateTimeFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* mutable_during_date_time(int index);
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
      mutable_during_date_time();
  const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& during_date_time(int index) const;
  ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* add_during_date_time();
  const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
      during_date_time() const;

  // .com.here.pb.hdmap.shared.v1.core.SpeedLimit override_speed_limit = 1;
  bool has_override_speed_limit() const;
  void clear_override_speed_limit();
  static const int kOverrideSpeedLimitFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& override_speed_limit() const;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* release_override_speed_limit();
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* mutable_override_speed_limit();
  void set_allocated_override_speed_limit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier > during_date_time_;
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit_LaneDependent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LaneDependent) */ {
 public:
  ConditionalSpeedLimit_LaneDependent();
  virtual ~ConditionalSpeedLimit_LaneDependent();

  ConditionalSpeedLimit_LaneDependent(const ConditionalSpeedLimit_LaneDependent& from);

  inline ConditionalSpeedLimit_LaneDependent& operator=(const ConditionalSpeedLimit_LaneDependent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit_LaneDependent(ConditionalSpeedLimit_LaneDependent&& from) noexcept
    : ConditionalSpeedLimit_LaneDependent() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit_LaneDependent& operator=(ConditionalSpeedLimit_LaneDependent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit_LaneDependent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit_LaneDependent* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit_LaneDependent*>(
               &_ConditionalSpeedLimit_LaneDependent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ConditionalSpeedLimit_LaneDependent* other);
  friend void swap(ConditionalSpeedLimit_LaneDependent& a, ConditionalSpeedLimit_LaneDependent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit_LaneDependent* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_LaneDependent>(nullptr);
  }

  ConditionalSpeedLimit_LaneDependent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit_LaneDependent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit_LaneDependent& from);
  void MergeFrom(const ConditionalSpeedLimit_LaneDependent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit_LaneDependent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LaneDependent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalSpeedLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit) */ {
 public:
  ConditionalSpeedLimit();
  virtual ~ConditionalSpeedLimit();

  ConditionalSpeedLimit(const ConditionalSpeedLimit& from);

  inline ConditionalSpeedLimit& operator=(const ConditionalSpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalSpeedLimit(ConditionalSpeedLimit&& from) noexcept
    : ConditionalSpeedLimit() {
    *this = ::std::move(from);
  }

  inline ConditionalSpeedLimit& operator=(ConditionalSpeedLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalSpeedLimit& default_instance();

  enum SituationCase {
    kAdvisory = 1,
    kTrafficCalmingMeasures = 2,
    kLocationProximity = 3,
    kEnvironmental = 4,
    kTimeDependent = 5,
    kLaneDependent = 6,
    SITUATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalSpeedLimit* internal_default_instance() {
    return reinterpret_cast<const ConditionalSpeedLimit*>(
               &_ConditionalSpeedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ConditionalSpeedLimit* other);
  friend void swap(ConditionalSpeedLimit& a, ConditionalSpeedLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalSpeedLimit* New() const final {
    return CreateMaybeMessage<ConditionalSpeedLimit>(nullptr);
  }

  ConditionalSpeedLimit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalSpeedLimit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalSpeedLimit& from);
  void MergeFrom(const ConditionalSpeedLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalSpeedLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalSpeedLimit_Advisory Advisory;
  typedef ConditionalSpeedLimit_TrafficCalmingMeasures TrafficCalmingMeasures;
  typedef ConditionalSpeedLimit_LocationProximity LocationProximity;
  typedef ConditionalSpeedLimit_Environmental Environmental;
  typedef ConditionalSpeedLimit_TimeDependent TimeDependent;
  typedef ConditionalSpeedLimit_LaneDependent LaneDependent;

  // accessors -------------------------------------------------------

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory advisory = 1;
  bool has_advisory() const;
  void clear_advisory();
  static const int kAdvisoryFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory& advisory() const;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* release_advisory();
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* mutable_advisory();
  void set_allocated_advisory(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* advisory);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TrafficCalmingMeasures traffic_calming_measures = 2;
  bool has_traffic_calming_measures() const;
  void clear_traffic_calming_measures();
  static const int kTrafficCalmingMeasuresFieldNumber = 2;
  const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures& traffic_calming_measures() const;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* release_traffic_calming_measures();
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* mutable_traffic_calming_measures();
  void set_allocated_traffic_calming_measures(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* traffic_calming_measures);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity location_proximity = 3;
  bool has_location_proximity() const;
  void clear_location_proximity();
  static const int kLocationProximityFieldNumber = 3;
  const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity& location_proximity() const;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* release_location_proximity();
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* mutable_location_proximity();
  void set_allocated_location_proximity(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* location_proximity);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental environmental = 4;
  bool has_environmental() const;
  void clear_environmental();
  static const int kEnvironmentalFieldNumber = 4;
  const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental& environmental() const;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* release_environmental();
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* mutable_environmental();
  void set_allocated_environmental(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* environmental);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent time_dependent = 5;
  bool has_time_dependent() const;
  void clear_time_dependent();
  static const int kTimeDependentFieldNumber = 5;
  const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent& time_dependent() const;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* release_time_dependent();
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* mutable_time_dependent();
  void set_allocated_time_dependent(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* time_dependent);

  // .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LaneDependent lane_dependent = 6;
  bool has_lane_dependent() const;
  void clear_lane_dependent();
  static const int kLaneDependentFieldNumber = 6;
  const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent& lane_dependent() const;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* release_lane_dependent();
  ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* mutable_lane_dependent();
  void set_allocated_lane_dependent(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* lane_dependent);

  void clear_situation();
  SituationCase situation_case() const;
  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit)
 private:
  class HasBitSetters;
  void set_has_advisory();
  void set_has_traffic_calming_measures();
  void set_has_location_proximity();
  void set_has_environmental();
  void set_has_time_dependent();
  void set_has_lane_dependent();

  inline bool has_situation() const;
  inline void clear_has_situation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SituationUnion {
    SituationUnion() {}
    ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* advisory_;
    ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* traffic_calming_measures_;
    ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* location_proximity_;
    ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* environmental_;
    ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* time_dependent_;
    ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* lane_dependent_;
  } situation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ConditionalTollStructure final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure) */ {
 public:
  ConditionalTollStructure();
  virtual ~ConditionalTollStructure();

  ConditionalTollStructure(const ConditionalTollStructure& from);

  inline ConditionalTollStructure& operator=(const ConditionalTollStructure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalTollStructure(ConditionalTollStructure&& from) noexcept
    : ConditionalTollStructure() {
    *this = ::std::move(from);
  }

  inline ConditionalTollStructure& operator=(ConditionalTollStructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConditionalTollStructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalTollStructure* internal_default_instance() {
    return reinterpret_cast<const ConditionalTollStructure*>(
               &_ConditionalTollStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ConditionalTollStructure* other);
  friend void swap(ConditionalTollStructure& a, ConditionalTollStructure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalTollStructure* New() const final {
    return CreateMaybeMessage<ConditionalTollStructure>(nullptr);
  }

  ConditionalTollStructure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalTollStructure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalTollStructure& from);
  void MergeFrom(const ConditionalTollStructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalTollStructure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalTollStructure_TollStructureType TollStructureType;
  static const TollStructureType TollStructureType_UNKNOWN =
    ConditionalTollStructure_TollStructureType_TollStructureType_UNKNOWN;
  static const TollStructureType FIXED_FEE =
    ConditionalTollStructure_TollStructureType_FIXED_FEE;
  static const TollStructureType OBTAIN_TICKET =
    ConditionalTollStructure_TollStructureType_OBTAIN_TICKET;
  static const TollStructureType PAY_PER_TICKET =
    ConditionalTollStructure_TollStructureType_PAY_PER_TICKET;
  static const TollStructureType ELECTRONIC =
    ConditionalTollStructure_TollStructureType_ELECTRONIC;
  static inline bool TollStructureType_IsValid(int value) {
    return ConditionalTollStructure_TollStructureType_IsValid(value);
  }
  static const TollStructureType TollStructureType_MIN =
    ConditionalTollStructure_TollStructureType_TollStructureType_MIN;
  static const TollStructureType TollStructureType_MAX =
    ConditionalTollStructure_TollStructureType_TollStructureType_MAX;
  static const int TollStructureType_ARRAYSIZE =
    ConditionalTollStructure_TollStructureType_TollStructureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TollStructureType_descriptor() {
    return ConditionalTollStructure_TollStructureType_descriptor();
  }
  static inline const ::std::string& TollStructureType_Name(TollStructureType value) {
    return ConditionalTollStructure_TollStructureType_Name(value);
  }
  static inline bool TollStructureType_Parse(const ::std::string& name,
      TollStructureType* value) {
    return ConditionalTollStructure_TollStructureType_Parse(name, value);
  }

  typedef ConditionalTollStructure_TollPaymentMethod TollPaymentMethod;
  static const TollPaymentMethod TollPaymentMethod_UNKNOWN =
    ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_UNKNOWN;
  static const TollPaymentMethod CASH =
    ConditionalTollStructure_TollPaymentMethod_CASH;
  static const TollPaymentMethod BANK_CARD =
    ConditionalTollStructure_TollPaymentMethod_BANK_CARD;
  static const TollPaymentMethod CREDIT_CARD =
    ConditionalTollStructure_TollPaymentMethod_CREDIT_CARD;
  static const TollPaymentMethod PASS_OR_SUBSCRIPTION =
    ConditionalTollStructure_TollPaymentMethod_PASS_OR_SUBSCRIPTION;
  static const TollPaymentMethod TRANSPONDER =
    ConditionalTollStructure_TollPaymentMethod_TRANSPONDER;
  static const TollPaymentMethod VIDEO_TOLL_CHARGE =
    ConditionalTollStructure_TollPaymentMethod_VIDEO_TOLL_CHARGE;
  static const TollPaymentMethod EXACT_CASH =
    ConditionalTollStructure_TollPaymentMethod_EXACT_CASH;
  static const TollPaymentMethod TRAVEL_CARD =
    ConditionalTollStructure_TollPaymentMethod_TRAVEL_CARD;
  static inline bool TollPaymentMethod_IsValid(int value) {
    return ConditionalTollStructure_TollPaymentMethod_IsValid(value);
  }
  static const TollPaymentMethod TollPaymentMethod_MIN =
    ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_MIN;
  static const TollPaymentMethod TollPaymentMethod_MAX =
    ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_MAX;
  static const int TollPaymentMethod_ARRAYSIZE =
    ConditionalTollStructure_TollPaymentMethod_TollPaymentMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TollPaymentMethod_descriptor() {
    return ConditionalTollStructure_TollPaymentMethod_descriptor();
  }
  static inline const ::std::string& TollPaymentMethod_Name(TollPaymentMethod value) {
    return ConditionalTollStructure_TollPaymentMethod_Name(value);
  }
  static inline bool TollPaymentMethod_Parse(const ::std::string& name,
      TollPaymentMethod* value) {
    return ConditionalTollStructure_TollPaymentMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.TollStructureType toll_structure_type = 2;
  int toll_structure_type_size() const;
  void clear_toll_structure_type();
  static const int kTollStructureTypeFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType toll_structure_type(int index) const;
  void set_toll_structure_type(int index, ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType value);
  void add_toll_structure_type(::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType value);
  const ::google::protobuf::RepeatedField<int>& toll_structure_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_toll_structure_type();

  // repeated .com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.TollPaymentMethod toll_payment_method = 3;
  int toll_payment_method_size() const;
  void clear_toll_payment_method();
  static const int kTollPaymentMethodFieldNumber = 3;
  ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod toll_payment_method(int index) const;
  void set_toll_payment_method(int index, ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod value);
  void add_toll_payment_method(::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod value);
  const ::google::protobuf::RepeatedField<int>& toll_payment_method() const;
  ::google::protobuf::RepeatedField<int>* mutable_toll_payment_method();

  // .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
  bool has_applies_to() const;
  void clear_applies_to();
  static const int kAppliesToFieldNumber = 1;
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& applies_to() const;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* release_applies_to();
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* mutable_applies_to();
  void set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> toll_structure_type_;
  mutable std::atomic<int> _toll_structure_type_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> toll_payment_method_;
  mutable std::atomic<int> _toll_payment_method_cached_byte_size_;
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConditionalOvertakingRestriction

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalOvertakingRestriction::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalOvertakingRestriction::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalOvertakingRestriction::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalOvertakingRestriction::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_to)
  return applies_to_;
}
inline void ConditionalOvertakingRestriction::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
inline int ConditionalOvertakingRestriction::applies_during_size() const {
  return applies_during_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalOvertakingRestriction::mutable_applies_during(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_during)
  return applies_during_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalOvertakingRestriction::mutable_applies_during() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_during)
  return &applies_during_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalOvertakingRestriction::applies_during(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_during)
  return applies_during_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalOvertakingRestriction::add_applies_during() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_during)
  return applies_during_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalOvertakingRestriction::applies_during() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_during)
  return applies_during_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.WeatherType applies_in_weather_conditions = 3;
inline void ConditionalOvertakingRestriction::clear_applies_in_weather_conditions() {
  applies_in_weather_conditions_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType ConditionalOvertakingRestriction::applies_in_weather_conditions() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_in_weather_conditions)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType >(applies_in_weather_conditions_);
}
inline void ConditionalOvertakingRestriction::set_applies_in_weather_conditions(::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType value) {
  
  applies_in_weather_conditions_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalOvertakingRestriction.applies_in_weather_conditions)
}

// -------------------------------------------------------------------

// ConditionalUsageFeeRequired

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalUsageFeeRequired::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalUsageFeeRequired::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalUsageFeeRequired::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalUsageFeeRequired::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_to)
  return applies_to_;
}
inline void ConditionalUsageFeeRequired::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
inline int ConditionalUsageFeeRequired::applies_during_size() const {
  return applies_during_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalUsageFeeRequired::mutable_applies_during(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_during)
  return applies_during_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalUsageFeeRequired::mutable_applies_during() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_during)
  return &applies_during_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalUsageFeeRequired::applies_during(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_during)
  return applies_during_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalUsageFeeRequired::add_applies_during() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_during)
  return applies_during_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalUsageFeeRequired::applies_during() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.applies_during)
  return applies_during_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.TollFeatureType toll_feature_type = 3;
inline void ConditionalUsageFeeRequired::clear_toll_feature_type() {
  toll_feature_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType ConditionalUsageFeeRequired::toll_feature_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.toll_feature_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType >(toll_feature_type_);
}
inline void ConditionalUsageFeeRequired::set_toll_feature_type(::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType value) {
  
  toll_feature_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalUsageFeeRequired.toll_feature_type)
}

// -------------------------------------------------------------------

// ConditionalRestrictedDrivingManoeuvre

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalRestrictedDrivingManoeuvre::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalRestrictedDrivingManoeuvre::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalRestrictedDrivingManoeuvre::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalRestrictedDrivingManoeuvre::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_to)
  return applies_to_;
}
inline void ConditionalRestrictedDrivingManoeuvre::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
inline int ConditionalRestrictedDrivingManoeuvre::applies_during_size() const {
  return applies_during_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalRestrictedDrivingManoeuvre::mutable_applies_during(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_during)
  return applies_during_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalRestrictedDrivingManoeuvre::mutable_applies_during() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_during)
  return &applies_during_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalRestrictedDrivingManoeuvre::applies_during(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_during)
  return applies_during_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalRestrictedDrivingManoeuvre::add_applies_during() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_during)
  return applies_during_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalRestrictedDrivingManoeuvre::applies_during() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.applies_during)
  return applies_during_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.RestrictionType restriction_type = 3;
inline void ConditionalRestrictedDrivingManoeuvre::clear_restriction_type() {
  restriction_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType ConditionalRestrictedDrivingManoeuvre::restriction_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.restriction_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType >(restriction_type_);
}
inline void ConditionalRestrictedDrivingManoeuvre::set_restriction_type(::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType value) {
  
  restriction_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalRestrictedDrivingManoeuvre.restriction_type)
}

// -------------------------------------------------------------------

// ConditionalPermittedDrivingManoeuvre

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalPermittedDrivingManoeuvre::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalPermittedDrivingManoeuvre::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalPermittedDrivingManoeuvre::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalPermittedDrivingManoeuvre::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_to)
  return applies_to_;
}
inline void ConditionalPermittedDrivingManoeuvre::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
inline int ConditionalPermittedDrivingManoeuvre::applies_during_size() const {
  return applies_during_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalPermittedDrivingManoeuvre::mutable_applies_during(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_during)
  return applies_during_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalPermittedDrivingManoeuvre::mutable_applies_during() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_during)
  return &applies_during_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalPermittedDrivingManoeuvre::applies_during(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_during)
  return applies_during_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalPermittedDrivingManoeuvre::add_applies_during() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_during)
  return applies_during_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalPermittedDrivingManoeuvre::applies_during() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.applies_during)
  return applies_during_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.PermissionType permission_type = 3;
inline void ConditionalPermittedDrivingManoeuvre::clear_permission_type() {
  permission_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType ConditionalPermittedDrivingManoeuvre::permission_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.permission_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType >(permission_type_);
}
inline void ConditionalPermittedDrivingManoeuvre::set_permission_type(::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType value) {
  
  permission_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalPermittedDrivingManoeuvre.permission_type)
}

// -------------------------------------------------------------------

// ConditionalAccessRestriction

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalAccessRestriction::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalAccessRestriction::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalAccessRestriction::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalAccessRestriction::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_to)
  return applies_to_;
}
inline void ConditionalAccessRestriction::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
inline int ConditionalAccessRestriction::applies_during_size() const {
  return applies_during_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalAccessRestriction::mutable_applies_during(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_during)
  return applies_during_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalAccessRestriction::mutable_applies_during() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_during)
  return &applies_during_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalAccessRestriction::applies_during(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_during)
  return applies_during_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalAccessRestriction::add_applies_during() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_during)
  return applies_during_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalAccessRestriction::applies_during() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.applies_during)
  return applies_during_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.DependentAccessType dependent_access_type = 3;
inline void ConditionalAccessRestriction::clear_dependent_access_type() {
  dependent_access_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType ConditionalAccessRestriction::dependent_access_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.dependent_access_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType >(dependent_access_type_);
}
inline void ConditionalAccessRestriction::set_dependent_access_type(::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType value) {
  
  dependent_access_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalAccessRestriction.dependent_access_type)
}

// -------------------------------------------------------------------

// ConditionalAccessPermission

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalAccessPermission::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalAccessPermission::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalAccessPermission::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalAccessPermission::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_to)
  return applies_to_;
}
inline void ConditionalAccessPermission::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier applies_during = 2;
inline int ConditionalAccessPermission::applies_during_size() const {
  return applies_during_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalAccessPermission::mutable_applies_during(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_during)
  return applies_during_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalAccessPermission::mutable_applies_during() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_during)
  return &applies_during_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalAccessPermission::applies_during(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_during)
  return applies_during_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalAccessPermission::add_applies_during() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_during)
  return applies_during_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalAccessPermission::applies_during() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalAccessPermission.applies_during)
  return applies_during_;
}

// -------------------------------------------------------------------

// ConditionalSpeedLimit_Advisory

// .com.here.pb.hdmap.shared.v1.core.SpeedLimit override_speed_limit = 1;
inline bool ConditionalSpeedLimit_Advisory::has_override_speed_limit() const {
  return this != internal_default_instance() && override_speed_limit_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& ConditionalSpeedLimit_Advisory::override_speed_limit() const {
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* p = override_speed_limit_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory.override_speed_limit)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit*>(
      &::com::here::pb::hdmap::shared::v1::core::_SpeedLimit_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_Advisory::release_override_speed_limit() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory.override_speed_limit)
  
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* temp = override_speed_limit_;
  override_speed_limit_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_Advisory::mutable_override_speed_limit() {
  
  if (override_speed_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::SpeedLimit>(GetArenaNoVirtual());
    override_speed_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory.override_speed_limit)
  return override_speed_limit_;
}
inline void ConditionalSpeedLimit_Advisory::set_allocated_override_speed_limit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(override_speed_limit_);
  }
  if (override_speed_limit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      override_speed_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, override_speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  override_speed_limit_ = override_speed_limit;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory.override_speed_limit)
}

// -------------------------------------------------------------------

// ConditionalSpeedLimit_TrafficCalmingMeasures

// -------------------------------------------------------------------

// ConditionalSpeedLimit_LocationProximity

// .com.here.pb.hdmap.shared.v1.core.SpeedLimit overrideSpeedLimit = 1;
inline bool ConditionalSpeedLimit_LocationProximity::has_overridespeedlimit() const {
  return this != internal_default_instance() && overridespeedlimit_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& ConditionalSpeedLimit_LocationProximity::overridespeedlimit() const {
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* p = overridespeedlimit_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.overrideSpeedLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit*>(
      &::com::here::pb::hdmap::shared::v1::core::_SpeedLimit_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_LocationProximity::release_overridespeedlimit() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.overrideSpeedLimit)
  
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* temp = overridespeedlimit_;
  overridespeedlimit_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_LocationProximity::mutable_overridespeedlimit() {
  
  if (overridespeedlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::SpeedLimit>(GetArenaNoVirtual());
    overridespeedlimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.overrideSpeedLimit)
  return overridespeedlimit_;
}
inline void ConditionalSpeedLimit_LocationProximity::set_allocated_overridespeedlimit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* overridespeedlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(overridespeedlimit_);
  }
  if (overridespeedlimit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      overridespeedlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, overridespeedlimit, submessage_arena);
    }
    
  } else {
    
  }
  overridespeedlimit_ = overridespeedlimit;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.overrideSpeedLimit)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier during_date_time = 2;
inline int ConditionalSpeedLimit_LocationProximity::during_date_time_size() const {
  return during_date_time_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalSpeedLimit_LocationProximity::mutable_during_date_time(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.during_date_time)
  return during_date_time_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalSpeedLimit_LocationProximity::mutable_during_date_time() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.during_date_time)
  return &during_date_time_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalSpeedLimit_LocationProximity::during_date_time(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.during_date_time)
  return during_date_time_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalSpeedLimit_LocationProximity::add_during_date_time() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.during_date_time)
  return during_date_time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalSpeedLimit_LocationProximity::during_date_time() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.during_date_time)
  return during_date_time_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.LocationProximityType location_proximity_type = 3;
inline void ConditionalSpeedLimit_LocationProximity::clear_location_proximity_type() {
  location_proximity_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType ConditionalSpeedLimit_LocationProximity::location_proximity_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.location_proximity_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType >(location_proximity_type_);
}
inline void ConditionalSpeedLimit_LocationProximity::set_location_proximity_type(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType value) {
  
  location_proximity_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity.location_proximity_type)
}

// -------------------------------------------------------------------

// ConditionalSpeedLimit_Environmental

// .com.here.pb.hdmap.shared.v1.core.SpeedLimit override_speed_limit = 1;
inline bool ConditionalSpeedLimit_Environmental::has_override_speed_limit() const {
  return this != internal_default_instance() && override_speed_limit_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& ConditionalSpeedLimit_Environmental::override_speed_limit() const {
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* p = override_speed_limit_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.override_speed_limit)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit*>(
      &::com::here::pb::hdmap::shared::v1::core::_SpeedLimit_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_Environmental::release_override_speed_limit() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.override_speed_limit)
  
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* temp = override_speed_limit_;
  override_speed_limit_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_Environmental::mutable_override_speed_limit() {
  
  if (override_speed_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::SpeedLimit>(GetArenaNoVirtual());
    override_speed_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.override_speed_limit)
  return override_speed_limit_;
}
inline void ConditionalSpeedLimit_Environmental::set_allocated_override_speed_limit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(override_speed_limit_);
  }
  if (override_speed_limit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      override_speed_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, override_speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  override_speed_limit_ = override_speed_limit;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.override_speed_limit)
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.EnvironmentalType environmental_type = 2;
inline void ConditionalSpeedLimit_Environmental::clear_environmental_type() {
  environmental_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType ConditionalSpeedLimit_Environmental::environmental_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.environmental_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType >(environmental_type_);
}
inline void ConditionalSpeedLimit_Environmental::set_environmental_type(::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType value) {
  
  environmental_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental.environmental_type)
}

// -------------------------------------------------------------------

// ConditionalSpeedLimit_TimeDependent

// .com.here.pb.hdmap.shared.v1.core.SpeedLimit override_speed_limit = 1;
inline bool ConditionalSpeedLimit_TimeDependent::has_override_speed_limit() const {
  return this != internal_default_instance() && override_speed_limit_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit& ConditionalSpeedLimit_TimeDependent::override_speed_limit() const {
  const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* p = override_speed_limit_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.override_speed_limit)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::SpeedLimit*>(
      &::com::here::pb::hdmap::shared::v1::core::_SpeedLimit_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_TimeDependent::release_override_speed_limit() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.override_speed_limit)
  
  ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* temp = override_speed_limit_;
  override_speed_limit_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::SpeedLimit* ConditionalSpeedLimit_TimeDependent::mutable_override_speed_limit() {
  
  if (override_speed_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::SpeedLimit>(GetArenaNoVirtual());
    override_speed_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.override_speed_limit)
  return override_speed_limit_;
}
inline void ConditionalSpeedLimit_TimeDependent::set_allocated_override_speed_limit(::com::here::pb::hdmap::shared::v1::core::SpeedLimit* override_speed_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(override_speed_limit_);
  }
  if (override_speed_limit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      override_speed_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, override_speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  override_speed_limit_ = override_speed_limit;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.override_speed_limit)
}

// repeated .com.here.pb.hdmap.shared.v1.core.DateTimeModifier during_date_time = 2;
inline int ConditionalSpeedLimit_TimeDependent::during_date_time_size() const {
  return during_date_time_.size();
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalSpeedLimit_TimeDependent::mutable_during_date_time(int index) {
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.during_date_time)
  return during_date_time_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >*
ConditionalSpeedLimit_TimeDependent::mutable_during_date_time() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.during_date_time)
  return &during_date_time_;
}
inline const ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier& ConditionalSpeedLimit_TimeDependent::during_date_time(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.during_date_time)
  return during_date_time_.Get(index);
}
inline ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier* ConditionalSpeedLimit_TimeDependent::add_during_date_time() {
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.during_date_time)
  return during_date_time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::here::pb::hdmap::shared::v1::core::DateTimeModifier >&
ConditionalSpeedLimit_TimeDependent::during_date_time() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent.during_date_time)
  return during_date_time_;
}

// -------------------------------------------------------------------

// ConditionalSpeedLimit_LaneDependent

// -------------------------------------------------------------------

// ConditionalSpeedLimit

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Advisory advisory = 1;
inline bool ConditionalSpeedLimit::has_advisory() const {
  return situation_case() == kAdvisory;
}
inline void ConditionalSpeedLimit::set_has_advisory() {
  _oneof_case_[0] = kAdvisory;
}
inline void ConditionalSpeedLimit::clear_advisory() {
  if (has_advisory()) {
    delete situation_.advisory_;
    clear_has_situation();
  }
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* ConditionalSpeedLimit::release_advisory() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.advisory)
  if (has_advisory()) {
    clear_has_situation();
      ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* temp = situation_.advisory_;
    situation_.advisory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory& ConditionalSpeedLimit::advisory() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.advisory)
  return has_advisory()
      ? *situation_.advisory_
      : *reinterpret_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory*>(&::com::here::pb::hdmap::shared::v1::core::_ConditionalSpeedLimit_Advisory_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory* ConditionalSpeedLimit::mutable_advisory() {
  if (!has_advisory()) {
    clear_situation();
    set_has_advisory();
    situation_.advisory_ = CreateMaybeMessage< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Advisory >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.advisory)
  return situation_.advisory_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TrafficCalmingMeasures traffic_calming_measures = 2;
inline bool ConditionalSpeedLimit::has_traffic_calming_measures() const {
  return situation_case() == kTrafficCalmingMeasures;
}
inline void ConditionalSpeedLimit::set_has_traffic_calming_measures() {
  _oneof_case_[0] = kTrafficCalmingMeasures;
}
inline void ConditionalSpeedLimit::clear_traffic_calming_measures() {
  if (has_traffic_calming_measures()) {
    delete situation_.traffic_calming_measures_;
    clear_has_situation();
  }
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* ConditionalSpeedLimit::release_traffic_calming_measures() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.traffic_calming_measures)
  if (has_traffic_calming_measures()) {
    clear_has_situation();
      ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* temp = situation_.traffic_calming_measures_;
    situation_.traffic_calming_measures_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures& ConditionalSpeedLimit::traffic_calming_measures() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.traffic_calming_measures)
  return has_traffic_calming_measures()
      ? *situation_.traffic_calming_measures_
      : *reinterpret_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures*>(&::com::here::pb::hdmap::shared::v1::core::_ConditionalSpeedLimit_TrafficCalmingMeasures_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures* ConditionalSpeedLimit::mutable_traffic_calming_measures() {
  if (!has_traffic_calming_measures()) {
    clear_situation();
    set_has_traffic_calming_measures();
    situation_.traffic_calming_measures_ = CreateMaybeMessage< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TrafficCalmingMeasures >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.traffic_calming_measures)
  return situation_.traffic_calming_measures_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LocationProximity location_proximity = 3;
inline bool ConditionalSpeedLimit::has_location_proximity() const {
  return situation_case() == kLocationProximity;
}
inline void ConditionalSpeedLimit::set_has_location_proximity() {
  _oneof_case_[0] = kLocationProximity;
}
inline void ConditionalSpeedLimit::clear_location_proximity() {
  if (has_location_proximity()) {
    delete situation_.location_proximity_;
    clear_has_situation();
  }
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* ConditionalSpeedLimit::release_location_proximity() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.location_proximity)
  if (has_location_proximity()) {
    clear_has_situation();
      ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* temp = situation_.location_proximity_;
    situation_.location_proximity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity& ConditionalSpeedLimit::location_proximity() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.location_proximity)
  return has_location_proximity()
      ? *situation_.location_proximity_
      : *reinterpret_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity*>(&::com::here::pb::hdmap::shared::v1::core::_ConditionalSpeedLimit_LocationProximity_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity* ConditionalSpeedLimit::mutable_location_proximity() {
  if (!has_location_proximity()) {
    clear_situation();
    set_has_location_proximity();
    situation_.location_proximity_ = CreateMaybeMessage< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.location_proximity)
  return situation_.location_proximity_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.Environmental environmental = 4;
inline bool ConditionalSpeedLimit::has_environmental() const {
  return situation_case() == kEnvironmental;
}
inline void ConditionalSpeedLimit::set_has_environmental() {
  _oneof_case_[0] = kEnvironmental;
}
inline void ConditionalSpeedLimit::clear_environmental() {
  if (has_environmental()) {
    delete situation_.environmental_;
    clear_has_situation();
  }
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* ConditionalSpeedLimit::release_environmental() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.environmental)
  if (has_environmental()) {
    clear_has_situation();
      ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* temp = situation_.environmental_;
    situation_.environmental_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental& ConditionalSpeedLimit::environmental() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.environmental)
  return has_environmental()
      ? *situation_.environmental_
      : *reinterpret_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental*>(&::com::here::pb::hdmap::shared::v1::core::_ConditionalSpeedLimit_Environmental_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental* ConditionalSpeedLimit::mutable_environmental() {
  if (!has_environmental()) {
    clear_situation();
    set_has_environmental();
    situation_.environmental_ = CreateMaybeMessage< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.environmental)
  return situation_.environmental_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.TimeDependent time_dependent = 5;
inline bool ConditionalSpeedLimit::has_time_dependent() const {
  return situation_case() == kTimeDependent;
}
inline void ConditionalSpeedLimit::set_has_time_dependent() {
  _oneof_case_[0] = kTimeDependent;
}
inline void ConditionalSpeedLimit::clear_time_dependent() {
  if (has_time_dependent()) {
    delete situation_.time_dependent_;
    clear_has_situation();
  }
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* ConditionalSpeedLimit::release_time_dependent() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.time_dependent)
  if (has_time_dependent()) {
    clear_has_situation();
      ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* temp = situation_.time_dependent_;
    situation_.time_dependent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent& ConditionalSpeedLimit::time_dependent() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.time_dependent)
  return has_time_dependent()
      ? *situation_.time_dependent_
      : *reinterpret_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent*>(&::com::here::pb::hdmap::shared::v1::core::_ConditionalSpeedLimit_TimeDependent_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent* ConditionalSpeedLimit::mutable_time_dependent() {
  if (!has_time_dependent()) {
    clear_situation();
    set_has_time_dependent();
    situation_.time_dependent_ = CreateMaybeMessage< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_TimeDependent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.time_dependent)
  return situation_.time_dependent_;
}

// .com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.LaneDependent lane_dependent = 6;
inline bool ConditionalSpeedLimit::has_lane_dependent() const {
  return situation_case() == kLaneDependent;
}
inline void ConditionalSpeedLimit::set_has_lane_dependent() {
  _oneof_case_[0] = kLaneDependent;
}
inline void ConditionalSpeedLimit::clear_lane_dependent() {
  if (has_lane_dependent()) {
    delete situation_.lane_dependent_;
    clear_has_situation();
  }
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* ConditionalSpeedLimit::release_lane_dependent() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.lane_dependent)
  if (has_lane_dependent()) {
    clear_has_situation();
      ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* temp = situation_.lane_dependent_;
    situation_.lane_dependent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent& ConditionalSpeedLimit::lane_dependent() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.lane_dependent)
  return has_lane_dependent()
      ? *situation_.lane_dependent_
      : *reinterpret_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent*>(&::com::here::pb::hdmap::shared::v1::core::_ConditionalSpeedLimit_LaneDependent_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent* ConditionalSpeedLimit::mutable_lane_dependent() {
  if (!has_lane_dependent()) {
    clear_situation();
    set_has_lane_dependent();
    situation_.lane_dependent_ = CreateMaybeMessage< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LaneDependent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalSpeedLimit.lane_dependent)
  return situation_.lane_dependent_;
}

inline bool ConditionalSpeedLimit::has_situation() const {
  return situation_case() != SITUATION_NOT_SET;
}
inline void ConditionalSpeedLimit::clear_has_situation() {
  _oneof_case_[0] = SITUATION_NOT_SET;
}
inline ConditionalSpeedLimit::SituationCase ConditionalSpeedLimit::situation_case() const {
  return ConditionalSpeedLimit::SituationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConditionalTollStructure

// .com.here.pb.hdmap.shared.v1.core.RoadUsers applies_to = 1;
inline bool ConditionalTollStructure::has_applies_to() const {
  return this != internal_default_instance() && applies_to_ != nullptr;
}
inline const ::com::here::pb::hdmap::shared::v1::core::RoadUsers& ConditionalTollStructure::applies_to() const {
  const ::com::here::pb::hdmap::shared::v1::core::RoadUsers* p = applies_to_;
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.applies_to)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::here::pb::hdmap::shared::v1::core::RoadUsers*>(
      &::com::here::pb::hdmap::shared::v1::core::_RoadUsers_default_instance_);
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalTollStructure::release_applies_to() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.applies_to)
  
  ::com::here::pb::hdmap::shared::v1::core::RoadUsers* temp = applies_to_;
  applies_to_ = nullptr;
  return temp;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadUsers* ConditionalTollStructure::mutable_applies_to() {
  
  if (applies_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadUsers>(GetArenaNoVirtual());
    applies_to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.applies_to)
  return applies_to_;
}
inline void ConditionalTollStructure::set_allocated_applies_to(::com::here::pb::hdmap::shared::v1::core::RoadUsers* applies_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(applies_to_);
  }
  if (applies_to) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      applies_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, applies_to, submessage_arena);
    }
    
  } else {
    
  }
  applies_to_ = applies_to;
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.applies_to)
}

// repeated .com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.TollStructureType toll_structure_type = 2;
inline int ConditionalTollStructure::toll_structure_type_size() const {
  return toll_structure_type_.size();
}
inline void ConditionalTollStructure::clear_toll_structure_type() {
  toll_structure_type_.Clear();
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType ConditionalTollStructure::toll_structure_type(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_structure_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType >(toll_structure_type_.Get(index));
}
inline void ConditionalTollStructure::set_toll_structure_type(int index, ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType value) {
  toll_structure_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_structure_type)
}
inline void ConditionalTollStructure::add_toll_structure_type(::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType value) {
  toll_structure_type_.Add(value);
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_structure_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ConditionalTollStructure::toll_structure_type() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_structure_type)
  return toll_structure_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ConditionalTollStructure::mutable_toll_structure_type() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_structure_type)
  return &toll_structure_type_;
}

// repeated .com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.TollPaymentMethod toll_payment_method = 3;
inline int ConditionalTollStructure::toll_payment_method_size() const {
  return toll_payment_method_.size();
}
inline void ConditionalTollStructure::clear_toll_payment_method() {
  toll_payment_method_.Clear();
}
inline ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod ConditionalTollStructure::toll_payment_method(int index) const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_payment_method)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod >(toll_payment_method_.Get(index));
}
inline void ConditionalTollStructure::set_toll_payment_method(int index, ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod value) {
  toll_payment_method_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_payment_method)
}
inline void ConditionalTollStructure::add_toll_payment_method(::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod value) {
  toll_payment_method_.Add(value);
  // @@protoc_insertion_point(field_add:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_payment_method)
}
inline const ::google::protobuf::RepeatedField<int>&
ConditionalTollStructure::toll_payment_method() const {
  // @@protoc_insertion_point(field_list:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_payment_method)
  return toll_payment_method_;
}
inline ::google::protobuf::RepeatedField<int>*
ConditionalTollStructure::mutable_toll_payment_method() {
  // @@protoc_insertion_point(field_mutable_list:com.here.pb.hdmap.shared.v1.core.ConditionalTollStructure.toll_payment_method)
  return &toll_payment_method_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace v1
}  // namespace shared
}  // namespace hdmap
}  // namespace pb
}  // namespace here
}  // namespace com

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalOvertakingRestriction_WeatherType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalUsageFeeRequired_TollFeatureType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalRestrictedDrivingManoeuvre_RestrictionType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalPermittedDrivingManoeuvre_PermissionType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalAccessRestriction_DependentAccessType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_LocationProximity_LocationProximityType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalSpeedLimit_Environmental_EnvironmentalType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollStructureType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod>() {
  return ::com::here::pb::hdmap::shared::v1::core::ConditionalTollStructure_TollPaymentMethod_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2fconditional_2dattributes_2eproto
