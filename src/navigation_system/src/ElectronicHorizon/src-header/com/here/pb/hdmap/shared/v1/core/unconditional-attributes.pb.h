// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com/here/pb/hdmap/shared/v1/core/unconditional-attributes.proto

#ifndef PROTOBUF_INCLUDED_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto
#define PROTOBUF_INCLUDED_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "com/here/pb/hdmap/shared/v1/core/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto();
namespace com {
namespace here {
namespace pb {
namespace hdmap {
namespace shared {
namespace v1 {
namespace core {
class BuiltUpAreaRoad;
class BuiltUpAreaRoadDefaultTypeInternal;
extern BuiltUpAreaRoadDefaultTypeInternal _BuiltUpAreaRoad_default_instance_;
class ComplexIntersection;
class ComplexIntersectionDefaultTypeInternal;
extern ComplexIntersectionDefaultTypeInternal _ComplexIntersection_default_instance_;
class CoreMapReference;
class CoreMapReferenceDefaultTypeInternal;
extern CoreMapReferenceDefaultTypeInternal _CoreMapReference_default_instance_;
class RoadDivider;
class RoadDividerDefaultTypeInternal;
extern RoadDividerDefaultTypeInternal _RoadDivider_default_instance_;
class RoadIdentifiers;
class RoadIdentifiersDefaultTypeInternal;
extern RoadIdentifiersDefaultTypeInternal _RoadIdentifiers_default_instance_;
class TrafficMessageChannelCode;
class TrafficMessageChannelCodeDefaultTypeInternal;
extern TrafficMessageChannelCodeDefaultTypeInternal _TrafficMessageChannelCode_default_instance_;
class VariableSpeedLimit;
class VariableSpeedLimitDefaultTypeInternal;
extern VariableSpeedLimitDefaultTypeInternal _VariableSpeedLimit_default_instance_;
class VariableSpeedSign;
class VariableSpeedSignDefaultTypeInternal;
extern VariableSpeedSignDefaultTypeInternal _VariableSpeedSign_default_instance_;
}  // namespace core
}  // namespace v1
}  // namespace shared
}  // namespace hdmap
}  // namespace pb
}  // namespace here
}  // namespace com
namespace google {
namespace protobuf {
template<> ::com::here::pb::hdmap::shared::v1::core::BuiltUpAreaRoad* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::BuiltUpAreaRoad>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::ComplexIntersection>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::CoreMapReference* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::CoreMapReference>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::RoadDivider* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadDivider>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::VariableSpeedLimit* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::VariableSpeedLimit>(Arena*);
template<> ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign* Arena::CreateMaybeMessage<::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace com {
namespace here {
namespace pb {
namespace hdmap {
namespace shared {
namespace v1 {
namespace core {

enum TrafficMessageChannelCode_LocationDisposition {
  TrafficMessageChannelCode_LocationDisposition_LocationDisposition_UNKNOWN = 0,
  TrafficMessageChannelCode_LocationDisposition_EXTERNAL_POSITIVE_DIRECTION = 1,
  TrafficMessageChannelCode_LocationDisposition_EXTERNAL_NEGATIVE_DIRECTION = 2,
  TrafficMessageChannelCode_LocationDisposition_INTERNAL_POSITIVE_DIRECTION = 3,
  TrafficMessageChannelCode_LocationDisposition_INTERNAL_NEGATIVE_DIRECTION = 4,
  TrafficMessageChannelCode_LocationDisposition_TrafficMessageChannelCode_LocationDisposition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  TrafficMessageChannelCode_LocationDisposition_TrafficMessageChannelCode_LocationDisposition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool TrafficMessageChannelCode_LocationDisposition_IsValid(int value);
const TrafficMessageChannelCode_LocationDisposition TrafficMessageChannelCode_LocationDisposition_LocationDisposition_MIN = TrafficMessageChannelCode_LocationDisposition_LocationDisposition_UNKNOWN;
const TrafficMessageChannelCode_LocationDisposition TrafficMessageChannelCode_LocationDisposition_LocationDisposition_MAX = TrafficMessageChannelCode_LocationDisposition_INTERNAL_NEGATIVE_DIRECTION;
const int TrafficMessageChannelCode_LocationDisposition_LocationDisposition_ARRAYSIZE = TrafficMessageChannelCode_LocationDisposition_LocationDisposition_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficMessageChannelCode_LocationDisposition_descriptor();
inline const ::std::string& TrafficMessageChannelCode_LocationDisposition_Name(TrafficMessageChannelCode_LocationDisposition value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficMessageChannelCode_LocationDisposition_descriptor(), value);
}
inline bool TrafficMessageChannelCode_LocationDisposition_Parse(
    const ::std::string& name, TrafficMessageChannelCode_LocationDisposition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficMessageChannelCode_LocationDisposition>(
    TrafficMessageChannelCode_LocationDisposition_descriptor(), name, value);
}
enum VariableSpeedSign_SignLocation {
  VariableSpeedSign_SignLocation_SignLocation_UNKNOWN = 0,
  VariableSpeedSign_SignLocation_LEFT = 1,
  VariableSpeedSign_SignLocation_RIGHT = 2,
  VariableSpeedSign_SignLocation_OVERHEAD = 3,
  VariableSpeedSign_SignLocation_VariableSpeedSign_SignLocation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  VariableSpeedSign_SignLocation_VariableSpeedSign_SignLocation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool VariableSpeedSign_SignLocation_IsValid(int value);
const VariableSpeedSign_SignLocation VariableSpeedSign_SignLocation_SignLocation_MIN = VariableSpeedSign_SignLocation_SignLocation_UNKNOWN;
const VariableSpeedSign_SignLocation VariableSpeedSign_SignLocation_SignLocation_MAX = VariableSpeedSign_SignLocation_OVERHEAD;
const int VariableSpeedSign_SignLocation_SignLocation_ARRAYSIZE = VariableSpeedSign_SignLocation_SignLocation_MAX + 1;

const ::google::protobuf::EnumDescriptor* VariableSpeedSign_SignLocation_descriptor();
inline const ::std::string& VariableSpeedSign_SignLocation_Name(VariableSpeedSign_SignLocation value) {
  return ::google::protobuf::internal::NameOfEnum(
    VariableSpeedSign_SignLocation_descriptor(), value);
}
inline bool VariableSpeedSign_SignLocation_Parse(
    const ::std::string& name, VariableSpeedSign_SignLocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VariableSpeedSign_SignLocation>(
    VariableSpeedSign_SignLocation_descriptor(), name, value);
}
enum ComplexIntersection_IntersectionCategory {
  ComplexIntersection_IntersectionCategory_ComplexIntersection_UNKNOWN = 0,
  ComplexIntersection_IntersectionCategory_INTERSECTION_INTERNAL = 1,
  ComplexIntersection_IntersectionCategory_MANOEUVRE = 2,
  ComplexIntersection_IntersectionCategory_INDESCRIBABLE = 3,
  ComplexIntersection_IntersectionCategory_ROUNDABOUT = 4,
  ComplexIntersection_IntersectionCategory_UNDEFINED_TRAFFIC_INTERNAL = 5,
  ComplexIntersection_IntersectionCategory_SPECIAL_TRAFFIC_FIGURE = 6,
  ComplexIntersection_IntersectionCategory_ComplexIntersection_IntersectionCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ComplexIntersection_IntersectionCategory_ComplexIntersection_IntersectionCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ComplexIntersection_IntersectionCategory_IsValid(int value);
const ComplexIntersection_IntersectionCategory ComplexIntersection_IntersectionCategory_IntersectionCategory_MIN = ComplexIntersection_IntersectionCategory_ComplexIntersection_UNKNOWN;
const ComplexIntersection_IntersectionCategory ComplexIntersection_IntersectionCategory_IntersectionCategory_MAX = ComplexIntersection_IntersectionCategory_SPECIAL_TRAFFIC_FIGURE;
const int ComplexIntersection_IntersectionCategory_IntersectionCategory_ARRAYSIZE = ComplexIntersection_IntersectionCategory_IntersectionCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexIntersection_IntersectionCategory_descriptor();
inline const ::std::string& ComplexIntersection_IntersectionCategory_Name(ComplexIntersection_IntersectionCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexIntersection_IntersectionCategory_descriptor(), value);
}
inline bool ComplexIntersection_IntersectionCategory_Parse(
    const ::std::string& name, ComplexIntersection_IntersectionCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexIntersection_IntersectionCategory>(
    ComplexIntersection_IntersectionCategory_descriptor(), name, value);
}
enum RoadDivider_RoadDividerType {
  RoadDivider_RoadDividerType_RoadDividerType_UNKNOWN = 0,
  RoadDivider_RoadDividerType_LEGAL = 1,
  RoadDivider_RoadDividerType_PHYSICAL = 2,
  RoadDivider_RoadDividerType_RoadDivider_RoadDividerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RoadDivider_RoadDividerType_RoadDivider_RoadDividerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RoadDivider_RoadDividerType_IsValid(int value);
const RoadDivider_RoadDividerType RoadDivider_RoadDividerType_RoadDividerType_MIN = RoadDivider_RoadDividerType_RoadDividerType_UNKNOWN;
const RoadDivider_RoadDividerType RoadDivider_RoadDividerType_RoadDividerType_MAX = RoadDivider_RoadDividerType_PHYSICAL;
const int RoadDivider_RoadDividerType_RoadDividerType_ARRAYSIZE = RoadDivider_RoadDividerType_RoadDividerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadDivider_RoadDividerType_descriptor();
inline const ::std::string& RoadDivider_RoadDividerType_Name(RoadDivider_RoadDividerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadDivider_RoadDividerType_descriptor(), value);
}
inline bool RoadDivider_RoadDividerType_Parse(
    const ::std::string& name, RoadDivider_RoadDividerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadDivider_RoadDividerType>(
    RoadDivider_RoadDividerType_descriptor(), name, value);
}
enum RoadDivider_IntersectionsAffected {
  RoadDivider_IntersectionsAffected_IntersectionsAffected_NONE = 0,
  RoadDivider_IntersectionsAffected_START = 1,
  RoadDivider_IntersectionsAffected_END = 2,
  RoadDivider_IntersectionsAffected_BOTH = 3,
  RoadDivider_IntersectionsAffected_RoadDivider_IntersectionsAffected_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RoadDivider_IntersectionsAffected_RoadDivider_IntersectionsAffected_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RoadDivider_IntersectionsAffected_IsValid(int value);
const RoadDivider_IntersectionsAffected RoadDivider_IntersectionsAffected_IntersectionsAffected_MIN = RoadDivider_IntersectionsAffected_IntersectionsAffected_NONE;
const RoadDivider_IntersectionsAffected RoadDivider_IntersectionsAffected_IntersectionsAffected_MAX = RoadDivider_IntersectionsAffected_BOTH;
const int RoadDivider_IntersectionsAffected_IntersectionsAffected_ARRAYSIZE = RoadDivider_IntersectionsAffected_IntersectionsAffected_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadDivider_IntersectionsAffected_descriptor();
inline const ::std::string& RoadDivider_IntersectionsAffected_Name(RoadDivider_IntersectionsAffected value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadDivider_IntersectionsAffected_descriptor(), value);
}
inline bool RoadDivider_IntersectionsAffected_Parse(
    const ::std::string& name, RoadDivider_IntersectionsAffected* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadDivider_IntersectionsAffected>(
    RoadDivider_IntersectionsAffected_descriptor(), name, value);
}
enum RoadIdentifiers_RouteType {
  RoadIdentifiers_RouteType_RouteType_UNKNOWN = 0,
  RoadIdentifiers_RouteType_LEVEL_1_ROAD = 1,
  RoadIdentifiers_RouteType_LEVEL_2_ROAD = 2,
  RoadIdentifiers_RouteType_LEVEL_3_ROAD = 3,
  RoadIdentifiers_RouteType_LEVEL_4_ROAD = 4,
  RoadIdentifiers_RouteType_LEVEL_5_ROAD = 5,
  RoadIdentifiers_RouteType_LEVEL_6_ROAD = 6,
  RoadIdentifiers_RouteType_RoadIdentifiers_RouteType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RoadIdentifiers_RouteType_RoadIdentifiers_RouteType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RoadIdentifiers_RouteType_IsValid(int value);
const RoadIdentifiers_RouteType RoadIdentifiers_RouteType_RouteType_MIN = RoadIdentifiers_RouteType_RouteType_UNKNOWN;
const RoadIdentifiers_RouteType RoadIdentifiers_RouteType_RouteType_MAX = RoadIdentifiers_RouteType_LEVEL_6_ROAD;
const int RoadIdentifiers_RouteType_RouteType_ARRAYSIZE = RoadIdentifiers_RouteType_RouteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadIdentifiers_RouteType_descriptor();
inline const ::std::string& RoadIdentifiers_RouteType_Name(RoadIdentifiers_RouteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadIdentifiers_RouteType_descriptor(), value);
}
inline bool RoadIdentifiers_RouteType_Parse(
    const ::std::string& name, RoadIdentifiers_RouteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadIdentifiers_RouteType>(
    RoadIdentifiers_RouteType_descriptor(), name, value);
}
enum FunctionalClass {
  FunctionalClass_UNKNOWN = 0,
  FC_1 = 1,
  FC_2 = 2,
  FC_3 = 3,
  FC_4 = 4,
  FC_5 = 5,
  FunctionalClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FunctionalClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FunctionalClass_IsValid(int value);
const FunctionalClass FunctionalClass_MIN = FunctionalClass_UNKNOWN;
const FunctionalClass FunctionalClass_MAX = FC_5;
const int FunctionalClass_ARRAYSIZE = FunctionalClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionalClass_descriptor();
inline const ::std::string& FunctionalClass_Name(FunctionalClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionalClass_descriptor(), value);
}
inline bool FunctionalClass_Parse(
    const ::std::string& name, FunctionalClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionalClass>(
    FunctionalClass_descriptor(), name, value);
}
enum SpeedCategory {
  SpeedCategory_UNKNOWN = 0,
  OVER_130_KMPH__80_MPH = 1,
  BTW_101_130_KMPH__65_80_MPH = 2,
  BTW_91_100_KMPH__55_64_MPH = 3,
  BTW_71_90_KMPH__41_54_MPH = 4,
  BTW_51_70_KMPH__31_40_MPH = 5,
  BTW_31_50_KMPH__21_30_MPH = 6,
  BTW_11_30_KMPH__6_20_MPH = 7,
  UNDER_11_KMPH__6_MPH = 8,
  SpeedCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SpeedCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SpeedCategory_IsValid(int value);
const SpeedCategory SpeedCategory_MIN = SpeedCategory_UNKNOWN;
const SpeedCategory SpeedCategory_MAX = UNDER_11_KMPH__6_MPH;
const int SpeedCategory_ARRAYSIZE = SpeedCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeedCategory_descriptor();
inline const ::std::string& SpeedCategory_Name(SpeedCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeedCategory_descriptor(), value);
}
inline bool SpeedCategory_Parse(
    const ::std::string& name, SpeedCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeedCategory>(
    SpeedCategory_descriptor(), name, value);
}
// ===================================================================

class CoreMapReference final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.CoreMapReference) */ {
 public:
  CoreMapReference();
  virtual ~CoreMapReference();

  CoreMapReference(const CoreMapReference& from);

  inline CoreMapReference& operator=(const CoreMapReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoreMapReference(CoreMapReference&& from) noexcept
    : CoreMapReference() {
    *this = ::std::move(from);
  }

  inline CoreMapReference& operator=(CoreMapReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CoreMapReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoreMapReference* internal_default_instance() {
    return reinterpret_cast<const CoreMapReference*>(
               &_CoreMapReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CoreMapReference* other);
  friend void swap(CoreMapReference& a, CoreMapReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoreMapReference* New() const final {
    return CreateMaybeMessage<CoreMapReference>(nullptr);
  }

  CoreMapReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoreMapReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoreMapReference& from);
  void MergeFrom(const CoreMapReference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoreMapReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 pvid = 1;
  void clear_pvid();
  static const int kPvidFieldNumber = 1;
  ::google::protobuf::uint32 pvid() const;
  void set_pvid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.CoreMapReference)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 pvid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class VariableSpeedLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit) */ {
 public:
  VariableSpeedLimit();
  virtual ~VariableSpeedLimit();

  VariableSpeedLimit(const VariableSpeedLimit& from);

  inline VariableSpeedLimit& operator=(const VariableSpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VariableSpeedLimit(VariableSpeedLimit&& from) noexcept
    : VariableSpeedLimit() {
    *this = ::std::move(from);
  }

  inline VariableSpeedLimit& operator=(VariableSpeedLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VariableSpeedLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VariableSpeedLimit* internal_default_instance() {
    return reinterpret_cast<const VariableSpeedLimit*>(
               &_VariableSpeedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(VariableSpeedLimit* other);
  friend void swap(VariableSpeedLimit& a, VariableSpeedLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VariableSpeedLimit* New() const final {
    return CreateMaybeMessage<VariableSpeedLimit>(nullptr);
  }

  VariableSpeedLimit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VariableSpeedLimit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VariableSpeedLimit& from);
  void MergeFrom(const VariableSpeedLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariableSpeedLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string variable_speed_sign_id = 1;
  void clear_variable_speed_sign_id();
  static const int kVariableSpeedSignIdFieldNumber = 1;
  const ::std::string& variable_speed_sign_id() const;
  void set_variable_speed_sign_id(const ::std::string& value);
  #if LANG_CXX11
  void set_variable_speed_sign_id(::std::string&& value);
  #endif
  void set_variable_speed_sign_id(const char* value);
  void set_variable_speed_sign_id(const char* value, size_t size);
  ::std::string* mutable_variable_speed_sign_id();
  ::std::string* release_variable_speed_sign_id();
  void set_allocated_variable_speed_sign_id(::std::string* variable_speed_sign_id);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr variable_speed_sign_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class TrafficMessageChannelCode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode) */ {
 public:
  TrafficMessageChannelCode();
  virtual ~TrafficMessageChannelCode();

  TrafficMessageChannelCode(const TrafficMessageChannelCode& from);

  inline TrafficMessageChannelCode& operator=(const TrafficMessageChannelCode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficMessageChannelCode(TrafficMessageChannelCode&& from) noexcept
    : TrafficMessageChannelCode() {
    *this = ::std::move(from);
  }

  inline TrafficMessageChannelCode& operator=(TrafficMessageChannelCode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TrafficMessageChannelCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficMessageChannelCode* internal_default_instance() {
    return reinterpret_cast<const TrafficMessageChannelCode*>(
               &_TrafficMessageChannelCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TrafficMessageChannelCode* other);
  friend void swap(TrafficMessageChannelCode& a, TrafficMessageChannelCode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficMessageChannelCode* New() const final {
    return CreateMaybeMessage<TrafficMessageChannelCode>(nullptr);
  }

  TrafficMessageChannelCode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficMessageChannelCode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficMessageChannelCode& from);
  void MergeFrom(const TrafficMessageChannelCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficMessageChannelCode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficMessageChannelCode_LocationDisposition LocationDisposition;
  static const LocationDisposition LocationDisposition_UNKNOWN =
    TrafficMessageChannelCode_LocationDisposition_LocationDisposition_UNKNOWN;
  static const LocationDisposition EXTERNAL_POSITIVE_DIRECTION =
    TrafficMessageChannelCode_LocationDisposition_EXTERNAL_POSITIVE_DIRECTION;
  static const LocationDisposition EXTERNAL_NEGATIVE_DIRECTION =
    TrafficMessageChannelCode_LocationDisposition_EXTERNAL_NEGATIVE_DIRECTION;
  static const LocationDisposition INTERNAL_POSITIVE_DIRECTION =
    TrafficMessageChannelCode_LocationDisposition_INTERNAL_POSITIVE_DIRECTION;
  static const LocationDisposition INTERNAL_NEGATIVE_DIRECTION =
    TrafficMessageChannelCode_LocationDisposition_INTERNAL_NEGATIVE_DIRECTION;
  static inline bool LocationDisposition_IsValid(int value) {
    return TrafficMessageChannelCode_LocationDisposition_IsValid(value);
  }
  static const LocationDisposition LocationDisposition_MIN =
    TrafficMessageChannelCode_LocationDisposition_LocationDisposition_MIN;
  static const LocationDisposition LocationDisposition_MAX =
    TrafficMessageChannelCode_LocationDisposition_LocationDisposition_MAX;
  static const int LocationDisposition_ARRAYSIZE =
    TrafficMessageChannelCode_LocationDisposition_LocationDisposition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LocationDisposition_descriptor() {
    return TrafficMessageChannelCode_LocationDisposition_descriptor();
  }
  static inline const ::std::string& LocationDisposition_Name(LocationDisposition value) {
    return TrafficMessageChannelCode_LocationDisposition_Name(value);
  }
  static inline bool LocationDisposition_Parse(const ::std::string& name,
      LocationDisposition* value) {
    return TrafficMessageChannelCode_LocationDisposition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ebu_country_code = 4;
  void clear_ebu_country_code();
  static const int kEbuCountryCodeFieldNumber = 4;
  const ::std::string& ebu_country_code() const;
  void set_ebu_country_code(const ::std::string& value);
  #if LANG_CXX11
  void set_ebu_country_code(::std::string&& value);
  #endif
  void set_ebu_country_code(const char* value);
  void set_ebu_country_code(const char* value, size_t size);
  ::std::string* mutable_ebu_country_code();
  ::std::string* release_ebu_country_code();
  void set_allocated_ebu_country_code(::std::string* ebu_country_code);

  // uint32 location_code = 1;
  void clear_location_code();
  static const int kLocationCodeFieldNumber = 1;
  ::google::protobuf::uint32 location_code() const;
  void set_location_code(::google::protobuf::uint32 value);

  // .com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.LocationDisposition location_disposition = 2;
  void clear_location_disposition();
  static const int kLocationDispositionFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition location_disposition() const;
  void set_location_disposition(::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition value);

  // uint32 location_table_number = 3;
  void clear_location_table_number();
  static const int kLocationTableNumberFieldNumber = 3;
  ::google::protobuf::uint32 location_table_number() const;
  void set_location_table_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ebu_country_code_;
  ::google::protobuf::uint32 location_code_;
  int location_disposition_;
  ::google::protobuf::uint32 location_table_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class VariableSpeedSign final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign) */ {
 public:
  VariableSpeedSign();
  virtual ~VariableSpeedSign();

  VariableSpeedSign(const VariableSpeedSign& from);

  inline VariableSpeedSign& operator=(const VariableSpeedSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VariableSpeedSign(VariableSpeedSign&& from) noexcept
    : VariableSpeedSign() {
    *this = ::std::move(from);
  }

  inline VariableSpeedSign& operator=(VariableSpeedSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VariableSpeedSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VariableSpeedSign* internal_default_instance() {
    return reinterpret_cast<const VariableSpeedSign*>(
               &_VariableSpeedSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(VariableSpeedSign* other);
  friend void swap(VariableSpeedSign& a, VariableSpeedSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VariableSpeedSign* New() const final {
    return CreateMaybeMessage<VariableSpeedSign>(nullptr);
  }

  VariableSpeedSign* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VariableSpeedSign>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VariableSpeedSign& from);
  void MergeFrom(const VariableSpeedSign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariableSpeedSign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VariableSpeedSign_SignLocation SignLocation;
  static const SignLocation SignLocation_UNKNOWN =
    VariableSpeedSign_SignLocation_SignLocation_UNKNOWN;
  static const SignLocation LEFT =
    VariableSpeedSign_SignLocation_LEFT;
  static const SignLocation RIGHT =
    VariableSpeedSign_SignLocation_RIGHT;
  static const SignLocation OVERHEAD =
    VariableSpeedSign_SignLocation_OVERHEAD;
  static inline bool SignLocation_IsValid(int value) {
    return VariableSpeedSign_SignLocation_IsValid(value);
  }
  static const SignLocation SignLocation_MIN =
    VariableSpeedSign_SignLocation_SignLocation_MIN;
  static const SignLocation SignLocation_MAX =
    VariableSpeedSign_SignLocation_SignLocation_MAX;
  static const int SignLocation_ARRAYSIZE =
    VariableSpeedSign_SignLocation_SignLocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SignLocation_descriptor() {
    return VariableSpeedSign_SignLocation_descriptor();
  }
  static inline const ::std::string& SignLocation_Name(SignLocation value) {
    return VariableSpeedSign_SignLocation_Name(value);
  }
  static inline bool SignLocation_Parse(const ::std::string& name,
      SignLocation* value) {
    return VariableSpeedSign_SignLocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string variable_speed_sign_id = 1;
  void clear_variable_speed_sign_id();
  static const int kVariableSpeedSignIdFieldNumber = 1;
  const ::std::string& variable_speed_sign_id() const;
  void set_variable_speed_sign_id(const ::std::string& value);
  #if LANG_CXX11
  void set_variable_speed_sign_id(::std::string&& value);
  #endif
  void set_variable_speed_sign_id(const char* value);
  void set_variable_speed_sign_id(const char* value, size_t size);
  ::std::string* mutable_variable_speed_sign_id();
  ::std::string* release_variable_speed_sign_id();
  void set_allocated_variable_speed_sign_id(::std::string* variable_speed_sign_id);

  // .com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.SignLocation sign_location = 2;
  void clear_sign_location();
  static const int kSignLocationFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation sign_location() const;
  void set_sign_location(::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr variable_speed_sign_id_;
  int sign_location_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class ComplexIntersection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.ComplexIntersection) */ {
 public:
  ComplexIntersection();
  virtual ~ComplexIntersection();

  ComplexIntersection(const ComplexIntersection& from);

  inline ComplexIntersection& operator=(const ComplexIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComplexIntersection(ComplexIntersection&& from) noexcept
    : ComplexIntersection() {
    *this = ::std::move(from);
  }

  inline ComplexIntersection& operator=(ComplexIntersection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ComplexIntersection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComplexIntersection* internal_default_instance() {
    return reinterpret_cast<const ComplexIntersection*>(
               &_ComplexIntersection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ComplexIntersection* other);
  friend void swap(ComplexIntersection& a, ComplexIntersection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComplexIntersection* New() const final {
    return CreateMaybeMessage<ComplexIntersection>(nullptr);
  }

  ComplexIntersection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ComplexIntersection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ComplexIntersection& from);
  void MergeFrom(const ComplexIntersection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComplexIntersection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ComplexIntersection_IntersectionCategory IntersectionCategory;
  static const IntersectionCategory ComplexIntersection_UNKNOWN =
    ComplexIntersection_IntersectionCategory_ComplexIntersection_UNKNOWN;
  static const IntersectionCategory INTERSECTION_INTERNAL =
    ComplexIntersection_IntersectionCategory_INTERSECTION_INTERNAL;
  static const IntersectionCategory MANOEUVRE =
    ComplexIntersection_IntersectionCategory_MANOEUVRE;
  static const IntersectionCategory INDESCRIBABLE =
    ComplexIntersection_IntersectionCategory_INDESCRIBABLE;
  static const IntersectionCategory ROUNDABOUT =
    ComplexIntersection_IntersectionCategory_ROUNDABOUT;
  static const IntersectionCategory UNDEFINED_TRAFFIC_INTERNAL =
    ComplexIntersection_IntersectionCategory_UNDEFINED_TRAFFIC_INTERNAL;
  static const IntersectionCategory SPECIAL_TRAFFIC_FIGURE =
    ComplexIntersection_IntersectionCategory_SPECIAL_TRAFFIC_FIGURE;
  static inline bool IntersectionCategory_IsValid(int value) {
    return ComplexIntersection_IntersectionCategory_IsValid(value);
  }
  static const IntersectionCategory IntersectionCategory_MIN =
    ComplexIntersection_IntersectionCategory_IntersectionCategory_MIN;
  static const IntersectionCategory IntersectionCategory_MAX =
    ComplexIntersection_IntersectionCategory_IntersectionCategory_MAX;
  static const int IntersectionCategory_ARRAYSIZE =
    ComplexIntersection_IntersectionCategory_IntersectionCategory_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IntersectionCategory_descriptor() {
    return ComplexIntersection_IntersectionCategory_descriptor();
  }
  static inline const ::std::string& IntersectionCategory_Name(IntersectionCategory value) {
    return ComplexIntersection_IntersectionCategory_Name(value);
  }
  static inline bool IntersectionCategory_Parse(const ::std::string& name,
      IntersectionCategory* value) {
    return ComplexIntersection_IntersectionCategory_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .com.here.pb.hdmap.shared.v1.core.ComplexIntersection.IntersectionCategory intersection_category = 1;
  void clear_intersection_category();
  static const int kIntersectionCategoryFieldNumber = 1;
  ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory intersection_category() const;
  void set_intersection_category(::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.ComplexIntersection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int intersection_category_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class BuiltUpAreaRoad final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.BuiltUpAreaRoad) */ {
 public:
  BuiltUpAreaRoad();
  virtual ~BuiltUpAreaRoad();

  BuiltUpAreaRoad(const BuiltUpAreaRoad& from);

  inline BuiltUpAreaRoad& operator=(const BuiltUpAreaRoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuiltUpAreaRoad(BuiltUpAreaRoad&& from) noexcept
    : BuiltUpAreaRoad() {
    *this = ::std::move(from);
  }

  inline BuiltUpAreaRoad& operator=(BuiltUpAreaRoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BuiltUpAreaRoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuiltUpAreaRoad* internal_default_instance() {
    return reinterpret_cast<const BuiltUpAreaRoad*>(
               &_BuiltUpAreaRoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BuiltUpAreaRoad* other);
  friend void swap(BuiltUpAreaRoad& a, BuiltUpAreaRoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuiltUpAreaRoad* New() const final {
    return CreateMaybeMessage<BuiltUpAreaRoad>(nullptr);
  }

  BuiltUpAreaRoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuiltUpAreaRoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BuiltUpAreaRoad& from);
  void MergeFrom(const BuiltUpAreaRoad& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuiltUpAreaRoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_built_up_area_road = 1;
  void clear_is_built_up_area_road();
  static const int kIsBuiltUpAreaRoadFieldNumber = 1;
  bool is_built_up_area_road() const;
  void set_is_built_up_area_road(bool value);

  // bool is_verified = 2;
  void clear_is_verified();
  static const int kIsVerifiedFieldNumber = 2;
  bool is_verified() const;
  void set_is_verified(bool value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.BuiltUpAreaRoad)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_built_up_area_road_;
  bool is_verified_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class RoadDivider final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.RoadDivider) */ {
 public:
  RoadDivider();
  virtual ~RoadDivider();

  RoadDivider(const RoadDivider& from);

  inline RoadDivider& operator=(const RoadDivider& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadDivider(RoadDivider&& from) noexcept
    : RoadDivider() {
    *this = ::std::move(from);
  }

  inline RoadDivider& operator=(RoadDivider&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RoadDivider& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadDivider* internal_default_instance() {
    return reinterpret_cast<const RoadDivider*>(
               &_RoadDivider_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RoadDivider* other);
  friend void swap(RoadDivider& a, RoadDivider& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadDivider* New() const final {
    return CreateMaybeMessage<RoadDivider>(nullptr);
  }

  RoadDivider* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadDivider>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadDivider& from);
  void MergeFrom(const RoadDivider& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadDivider* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadDivider_RoadDividerType RoadDividerType;
  static const RoadDividerType RoadDividerType_UNKNOWN =
    RoadDivider_RoadDividerType_RoadDividerType_UNKNOWN;
  static const RoadDividerType LEGAL =
    RoadDivider_RoadDividerType_LEGAL;
  static const RoadDividerType PHYSICAL =
    RoadDivider_RoadDividerType_PHYSICAL;
  static inline bool RoadDividerType_IsValid(int value) {
    return RoadDivider_RoadDividerType_IsValid(value);
  }
  static const RoadDividerType RoadDividerType_MIN =
    RoadDivider_RoadDividerType_RoadDividerType_MIN;
  static const RoadDividerType RoadDividerType_MAX =
    RoadDivider_RoadDividerType_RoadDividerType_MAX;
  static const int RoadDividerType_ARRAYSIZE =
    RoadDivider_RoadDividerType_RoadDividerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadDividerType_descriptor() {
    return RoadDivider_RoadDividerType_descriptor();
  }
  static inline const ::std::string& RoadDividerType_Name(RoadDividerType value) {
    return RoadDivider_RoadDividerType_Name(value);
  }
  static inline bool RoadDividerType_Parse(const ::std::string& name,
      RoadDividerType* value) {
    return RoadDivider_RoadDividerType_Parse(name, value);
  }

  typedef RoadDivider_IntersectionsAffected IntersectionsAffected;
  static const IntersectionsAffected IntersectionsAffected_NONE =
    RoadDivider_IntersectionsAffected_IntersectionsAffected_NONE;
  static const IntersectionsAffected START =
    RoadDivider_IntersectionsAffected_START;
  static const IntersectionsAffected END =
    RoadDivider_IntersectionsAffected_END;
  static const IntersectionsAffected BOTH =
    RoadDivider_IntersectionsAffected_BOTH;
  static inline bool IntersectionsAffected_IsValid(int value) {
    return RoadDivider_IntersectionsAffected_IsValid(value);
  }
  static const IntersectionsAffected IntersectionsAffected_MIN =
    RoadDivider_IntersectionsAffected_IntersectionsAffected_MIN;
  static const IntersectionsAffected IntersectionsAffected_MAX =
    RoadDivider_IntersectionsAffected_IntersectionsAffected_MAX;
  static const int IntersectionsAffected_ARRAYSIZE =
    RoadDivider_IntersectionsAffected_IntersectionsAffected_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IntersectionsAffected_descriptor() {
    return RoadDivider_IntersectionsAffected_descriptor();
  }
  static inline const ::std::string& IntersectionsAffected_Name(IntersectionsAffected value) {
    return RoadDivider_IntersectionsAffected_Name(value);
  }
  static inline bool IntersectionsAffected_Parse(const ::std::string& name,
      IntersectionsAffected* value) {
    return RoadDivider_IntersectionsAffected_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .com.here.pb.hdmap.shared.v1.core.RoadDivider.RoadDividerType divider_type = 1;
  void clear_divider_type();
  static const int kDividerTypeFieldNumber = 1;
  ::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType divider_type() const;
  void set_divider_type(::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType value);

  // .com.here.pb.hdmap.shared.v1.core.RoadDivider.IntersectionsAffected applies_to_intersection = 2;
  void clear_applies_to_intersection();
  static const int kAppliesToIntersectionFieldNumber = 2;
  ::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected applies_to_intersection() const;
  void set_applies_to_intersection(::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.RoadDivider)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int divider_type_;
  int applies_to_intersection_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// -------------------------------------------------------------------

class RoadIdentifiers final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.here.pb.hdmap.shared.v1.core.RoadIdentifiers) */ {
 public:
  RoadIdentifiers();
  virtual ~RoadIdentifiers();

  RoadIdentifiers(const RoadIdentifiers& from);

  inline RoadIdentifiers& operator=(const RoadIdentifiers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadIdentifiers(RoadIdentifiers&& from) noexcept
    : RoadIdentifiers() {
    *this = ::std::move(from);
  }

  inline RoadIdentifiers& operator=(RoadIdentifiers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RoadIdentifiers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadIdentifiers* internal_default_instance() {
    return reinterpret_cast<const RoadIdentifiers*>(
               &_RoadIdentifiers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RoadIdentifiers* other);
  friend void swap(RoadIdentifiers& a, RoadIdentifiers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadIdentifiers* New() const final {
    return CreateMaybeMessage<RoadIdentifiers>(nullptr);
  }

  RoadIdentifiers* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadIdentifiers>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadIdentifiers& from);
  void MergeFrom(const RoadIdentifiers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadIdentifiers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadIdentifiers_RouteType RouteType;
  static const RouteType RouteType_UNKNOWN =
    RoadIdentifiers_RouteType_RouteType_UNKNOWN;
  static const RouteType LEVEL_1_ROAD =
    RoadIdentifiers_RouteType_LEVEL_1_ROAD;
  static const RouteType LEVEL_2_ROAD =
    RoadIdentifiers_RouteType_LEVEL_2_ROAD;
  static const RouteType LEVEL_3_ROAD =
    RoadIdentifiers_RouteType_LEVEL_3_ROAD;
  static const RouteType LEVEL_4_ROAD =
    RoadIdentifiers_RouteType_LEVEL_4_ROAD;
  static const RouteType LEVEL_5_ROAD =
    RoadIdentifiers_RouteType_LEVEL_5_ROAD;
  static const RouteType LEVEL_6_ROAD =
    RoadIdentifiers_RouteType_LEVEL_6_ROAD;
  static inline bool RouteType_IsValid(int value) {
    return RoadIdentifiers_RouteType_IsValid(value);
  }
  static const RouteType RouteType_MIN =
    RoadIdentifiers_RouteType_RouteType_MIN;
  static const RouteType RouteType_MAX =
    RoadIdentifiers_RouteType_RouteType_MAX;
  static const int RouteType_ARRAYSIZE =
    RoadIdentifiers_RouteType_RouteType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RouteType_descriptor() {
    return RoadIdentifiers_RouteType_descriptor();
  }
  static inline const ::std::string& RouteType_Name(RouteType value) {
    return RoadIdentifiers_RouteType_Name(value);
  }
  static inline bool RouteType_Parse(const ::std::string& name,
      RouteType* value) {
    return RoadIdentifiers_RouteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .com.here.pb.hdmap.shared.v1.core.RoadIdentifiers.RouteType route_type = 1;
  void clear_route_type();
  static const int kRouteTypeFieldNumber = 1;
  ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType route_type() const;
  void set_route_type(::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType value);

  // @@protoc_insertion_point(class_scope:com.here.pb.hdmap.shared.v1.core.RoadIdentifiers)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int route_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CoreMapReference

// uint32 pvid = 1;
inline void CoreMapReference::clear_pvid() {
  pvid_ = 0u;
}
inline ::google::protobuf::uint32 CoreMapReference::pvid() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.CoreMapReference.pvid)
  return pvid_;
}
inline void CoreMapReference::set_pvid(::google::protobuf::uint32 value) {
  
  pvid_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.CoreMapReference.pvid)
}

// -------------------------------------------------------------------

// VariableSpeedLimit

// string variable_speed_sign_id = 1;
inline void VariableSpeedLimit::clear_variable_speed_sign_id() {
  variable_speed_sign_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VariableSpeedLimit::variable_speed_sign_id() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
  return variable_speed_sign_id_.GetNoArena();
}
inline void VariableSpeedLimit::set_variable_speed_sign_id(const ::std::string& value) {
  
  variable_speed_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
}
#if LANG_CXX11
inline void VariableSpeedLimit::set_variable_speed_sign_id(::std::string&& value) {
  
  variable_speed_sign_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
}
#endif
inline void VariableSpeedLimit::set_variable_speed_sign_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variable_speed_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
}
inline void VariableSpeedLimit::set_variable_speed_sign_id(const char* value, size_t size) {
  
  variable_speed_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
}
inline ::std::string* VariableSpeedLimit::mutable_variable_speed_sign_id() {
  
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
  return variable_speed_sign_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VariableSpeedLimit::release_variable_speed_sign_id() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
  
  return variable_speed_sign_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VariableSpeedLimit::set_allocated_variable_speed_sign_id(::std::string* variable_speed_sign_id) {
  if (variable_speed_sign_id != nullptr) {
    
  } else {
    
  }
  variable_speed_sign_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable_speed_sign_id);
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.VariableSpeedLimit.variable_speed_sign_id)
}

// -------------------------------------------------------------------

// TrafficMessageChannelCode

// uint32 location_code = 1;
inline void TrafficMessageChannelCode::clear_location_code() {
  location_code_ = 0u;
}
inline ::google::protobuf::uint32 TrafficMessageChannelCode::location_code() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.location_code)
  return location_code_;
}
inline void TrafficMessageChannelCode::set_location_code(::google::protobuf::uint32 value) {
  
  location_code_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.location_code)
}

// .com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.LocationDisposition location_disposition = 2;
inline void TrafficMessageChannelCode::clear_location_disposition() {
  location_disposition_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition TrafficMessageChannelCode::location_disposition() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.location_disposition)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition >(location_disposition_);
}
inline void TrafficMessageChannelCode::set_location_disposition(::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition value) {
  
  location_disposition_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.location_disposition)
}

// uint32 location_table_number = 3;
inline void TrafficMessageChannelCode::clear_location_table_number() {
  location_table_number_ = 0u;
}
inline ::google::protobuf::uint32 TrafficMessageChannelCode::location_table_number() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.location_table_number)
  return location_table_number_;
}
inline void TrafficMessageChannelCode::set_location_table_number(::google::protobuf::uint32 value) {
  
  location_table_number_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.location_table_number)
}

// string ebu_country_code = 4;
inline void TrafficMessageChannelCode::clear_ebu_country_code() {
  ebu_country_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficMessageChannelCode::ebu_country_code() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
  return ebu_country_code_.GetNoArena();
}
inline void TrafficMessageChannelCode::set_ebu_country_code(const ::std::string& value) {
  
  ebu_country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
}
#if LANG_CXX11
inline void TrafficMessageChannelCode::set_ebu_country_code(::std::string&& value) {
  
  ebu_country_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
}
#endif
inline void TrafficMessageChannelCode::set_ebu_country_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ebu_country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
}
inline void TrafficMessageChannelCode::set_ebu_country_code(const char* value, size_t size) {
  
  ebu_country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
}
inline ::std::string* TrafficMessageChannelCode::mutable_ebu_country_code() {
  
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
  return ebu_country_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficMessageChannelCode::release_ebu_country_code() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
  
  return ebu_country_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficMessageChannelCode::set_allocated_ebu_country_code(::std::string* ebu_country_code) {
  if (ebu_country_code != nullptr) {
    
  } else {
    
  }
  ebu_country_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ebu_country_code);
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.TrafficMessageChannelCode.ebu_country_code)
}

// -------------------------------------------------------------------

// VariableSpeedSign

// string variable_speed_sign_id = 1;
inline void VariableSpeedSign::clear_variable_speed_sign_id() {
  variable_speed_sign_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VariableSpeedSign::variable_speed_sign_id() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
  return variable_speed_sign_id_.GetNoArena();
}
inline void VariableSpeedSign::set_variable_speed_sign_id(const ::std::string& value) {
  
  variable_speed_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
}
#if LANG_CXX11
inline void VariableSpeedSign::set_variable_speed_sign_id(::std::string&& value) {
  
  variable_speed_sign_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
}
#endif
inline void VariableSpeedSign::set_variable_speed_sign_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variable_speed_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
}
inline void VariableSpeedSign::set_variable_speed_sign_id(const char* value, size_t size) {
  
  variable_speed_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
}
inline ::std::string* VariableSpeedSign::mutable_variable_speed_sign_id() {
  
  // @@protoc_insertion_point(field_mutable:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
  return variable_speed_sign_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VariableSpeedSign::release_variable_speed_sign_id() {
  // @@protoc_insertion_point(field_release:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
  
  return variable_speed_sign_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VariableSpeedSign::set_allocated_variable_speed_sign_id(::std::string* variable_speed_sign_id) {
  if (variable_speed_sign_id != nullptr) {
    
  } else {
    
  }
  variable_speed_sign_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable_speed_sign_id);
  // @@protoc_insertion_point(field_set_allocated:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.variable_speed_sign_id)
}

// .com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.SignLocation sign_location = 2;
inline void VariableSpeedSign::clear_sign_location() {
  sign_location_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation VariableSpeedSign::sign_location() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.sign_location)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation >(sign_location_);
}
inline void VariableSpeedSign::set_sign_location(::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation value) {
  
  sign_location_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.VariableSpeedSign.sign_location)
}

// -------------------------------------------------------------------

// ComplexIntersection

// .com.here.pb.hdmap.shared.v1.core.ComplexIntersection.IntersectionCategory intersection_category = 1;
inline void ComplexIntersection::clear_intersection_category() {
  intersection_category_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory ComplexIntersection::intersection_category() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.ComplexIntersection.intersection_category)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory >(intersection_category_);
}
inline void ComplexIntersection::set_intersection_category(::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory value) {
  
  intersection_category_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.ComplexIntersection.intersection_category)
}

// -------------------------------------------------------------------

// BuiltUpAreaRoad

// bool is_built_up_area_road = 1;
inline void BuiltUpAreaRoad::clear_is_built_up_area_road() {
  is_built_up_area_road_ = false;
}
inline bool BuiltUpAreaRoad::is_built_up_area_road() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.BuiltUpAreaRoad.is_built_up_area_road)
  return is_built_up_area_road_;
}
inline void BuiltUpAreaRoad::set_is_built_up_area_road(bool value) {
  
  is_built_up_area_road_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.BuiltUpAreaRoad.is_built_up_area_road)
}

// bool is_verified = 2;
inline void BuiltUpAreaRoad::clear_is_verified() {
  is_verified_ = false;
}
inline bool BuiltUpAreaRoad::is_verified() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.BuiltUpAreaRoad.is_verified)
  return is_verified_;
}
inline void BuiltUpAreaRoad::set_is_verified(bool value) {
  
  is_verified_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.BuiltUpAreaRoad.is_verified)
}

// -------------------------------------------------------------------

// RoadDivider

// .com.here.pb.hdmap.shared.v1.core.RoadDivider.RoadDividerType divider_type = 1;
inline void RoadDivider::clear_divider_type() {
  divider_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType RoadDivider::divider_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.RoadDivider.divider_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType >(divider_type_);
}
inline void RoadDivider::set_divider_type(::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType value) {
  
  divider_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.RoadDivider.divider_type)
}

// .com.here.pb.hdmap.shared.v1.core.RoadDivider.IntersectionsAffected applies_to_intersection = 2;
inline void RoadDivider::clear_applies_to_intersection() {
  applies_to_intersection_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected RoadDivider::applies_to_intersection() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.RoadDivider.applies_to_intersection)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected >(applies_to_intersection_);
}
inline void RoadDivider::set_applies_to_intersection(::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected value) {
  
  applies_to_intersection_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.RoadDivider.applies_to_intersection)
}

// -------------------------------------------------------------------

// RoadIdentifiers

// .com.here.pb.hdmap.shared.v1.core.RoadIdentifiers.RouteType route_type = 1;
inline void RoadIdentifiers::clear_route_type() {
  route_type_ = 0;
}
inline ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType RoadIdentifiers::route_type() const {
  // @@protoc_insertion_point(field_get:com.here.pb.hdmap.shared.v1.core.RoadIdentifiers.route_type)
  return static_cast< ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType >(route_type_);
}
inline void RoadIdentifiers::set_route_type(::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType value) {
  
  route_type_ = value;
  // @@protoc_insertion_point(field_set:com.here.pb.hdmap.shared.v1.core.RoadIdentifiers.route_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace v1
}  // namespace shared
}  // namespace hdmap
}  // namespace pb
}  // namespace here
}  // namespace com

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition>() {
  return ::com::here::pb::hdmap::shared::v1::core::TrafficMessageChannelCode_LocationDisposition_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation>() {
  return ::com::here::pb::hdmap::shared::v1::core::VariableSpeedSign_SignLocation_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory>() {
  return ::com::here::pb::hdmap::shared::v1::core::ComplexIntersection_IntersectionCategory_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType>() {
  return ::com::here::pb::hdmap::shared::v1::core::RoadDivider_RoadDividerType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected>() {
  return ::com::here::pb::hdmap::shared::v1::core::RoadDivider_IntersectionsAffected_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType>() {
  return ::com::here::pb::hdmap::shared::v1::core::RoadIdentifiers_RouteType_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::FunctionalClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::FunctionalClass>() {
  return ::com::here::pb::hdmap::shared::v1::core::FunctionalClass_descriptor();
}
template <> struct is_proto_enum< ::com::here::pb::hdmap::shared::v1::core::SpeedCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::here::pb::hdmap::shared::v1::core::SpeedCategory>() {
  return ::com::here::pb::hdmap::shared::v1::core::SpeedCategory_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_com_2fhere_2fpb_2fhdmap_2fshared_2fv1_2fcore_2funconditional_2dattributes_2eproto
