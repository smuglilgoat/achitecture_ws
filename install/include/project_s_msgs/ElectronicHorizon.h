// Generated by gencpp from file project_s_msgs/ElectronicHorizon.msg
// DO NOT EDIT!


#ifndef PROJECT_S_MSGS_MESSAGE_ELECTRONICHORIZON_H
#define PROJECT_S_MSGS_MESSAGE_ELECTRONICHORIZON_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehSegment.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehStub.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehSpotCurvature.h>
#include <std_msgs/UInt16.h>
#include <project_s_msgs/ehSpotCoordGeo.h>
#include <std_msgs/UInt16.h>
#include <project_s_msgs/ehSpotCoordGeo.h>
#include <std_msgs/UInt16.h>
#include <project_s_msgs/ehLineCoordGeo.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehME.h>
#include <project_s_msgs/ehNbrLineCoordGeo.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehSpotTrafficSign.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehPosition.h>
#include <project_s_msgs/ehSegmentME.h>
#include <std_msgs/UInt8.h>
#include <project_s_msgs/ehSegmentME.h>
#include <std_msgs/UInt8.h>

namespace project_s_msgs
{
template <class ContainerAllocator>
struct ElectronicHorizon_
{
  typedef ElectronicHorizon_<ContainerAllocator> Type;

  ElectronicHorizon_()
    : header()
    , id()
    , indexPath()
    , ehSegment()
    , NbrSegment()
    , ehStub()
    , NbrStub()
    , ehSpotCurvature()
    , NbrSpotCurvature()
    , ehSpotCoordGeoRight()
    , NbrSpotCoordGeoRight()
    , ehSpotCoordGeoLeft()
    , NbrSpotCoordGeoLeft()
    , ehLineCoordGeo()
    , QtyLineCoordGeo()
    , ehME()
    , ehNbrLineCoordGeo()
    , QtyNbrLineCoordGeo()
    , ehSpotTrafficSign()
    , NbrSpotTrafficSign()
    , ehPosition()
    , speedLimit_interpolMethod(0)
    , curvature_interpolMethod(0)
    , ehSegmentAO()
    , QtySegmentAO()
    , ehSegmentEO()
    , QtySegmentEO()  {
    }
  ElectronicHorizon_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , id(_alloc)
    , indexPath(_alloc)
    , ehSegment()
    , NbrSegment(_alloc)
    , ehStub()
    , NbrStub(_alloc)
    , ehSpotCurvature()
    , NbrSpotCurvature(_alloc)
    , ehSpotCoordGeoRight()
    , NbrSpotCoordGeoRight(_alloc)
    , ehSpotCoordGeoLeft()
    , NbrSpotCoordGeoLeft(_alloc)
    , ehLineCoordGeo()
    , QtyLineCoordGeo(_alloc)
    , ehME()
    , ehNbrLineCoordGeo()
    , QtyNbrLineCoordGeo(_alloc)
    , ehSpotTrafficSign()
    , NbrSpotTrafficSign(_alloc)
    , ehPosition(_alloc)
    , speedLimit_interpolMethod(0)
    , curvature_interpolMethod(0)
    , ehSegmentAO()
    , QtySegmentAO(_alloc)
    , ehSegmentEO()
    , QtySegmentEO(_alloc)  {
  (void)_alloc;
      ehSegment.assign( ::project_s_msgs::ehSegment_<ContainerAllocator> (_alloc));

      ehStub.assign( ::project_s_msgs::ehStub_<ContainerAllocator> (_alloc));

      ehSpotCurvature.assign( ::project_s_msgs::ehSpotCurvature_<ContainerAllocator> (_alloc));

      ehSpotCoordGeoRight.assign( ::project_s_msgs::ehSpotCoordGeo_<ContainerAllocator> (_alloc));

      ehSpotCoordGeoLeft.assign( ::project_s_msgs::ehSpotCoordGeo_<ContainerAllocator> (_alloc));

      ehLineCoordGeo.assign( ::project_s_msgs::ehLineCoordGeo_<ContainerAllocator> (_alloc));

      ehME.assign( ::project_s_msgs::ehME_<ContainerAllocator> (_alloc));

      ehNbrLineCoordGeo.assign( ::project_s_msgs::ehNbrLineCoordGeo_<ContainerAllocator> (_alloc));

      ehSpotTrafficSign.assign( ::project_s_msgs::ehSpotTrafficSign_<ContainerAllocator> (_alloc));

      ehSegmentAO.assign( ::project_s_msgs::ehSegmentME_<ContainerAllocator> (_alloc));

      ehSegmentEO.assign( ::project_s_msgs::ehSegmentME_<ContainerAllocator> (_alloc));
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _id_type;
  _id_type id;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _indexPath_type;
  _indexPath_type indexPath;

   typedef boost::array< ::project_s_msgs::ehSegment_<ContainerAllocator> , 50>  _ehSegment_type;
  _ehSegment_type ehSegment;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _NbrSegment_type;
  _NbrSegment_type NbrSegment;

   typedef boost::array< ::project_s_msgs::ehStub_<ContainerAllocator> , 10>  _ehStub_type;
  _ehStub_type ehStub;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _NbrStub_type;
  _NbrStub_type NbrStub;

   typedef boost::array< ::project_s_msgs::ehSpotCurvature_<ContainerAllocator> , 300>  _ehSpotCurvature_type;
  _ehSpotCurvature_type ehSpotCurvature;

   typedef  ::std_msgs::UInt16_<ContainerAllocator>  _NbrSpotCurvature_type;
  _NbrSpotCurvature_type NbrSpotCurvature;

   typedef boost::array< ::project_s_msgs::ehSpotCoordGeo_<ContainerAllocator> , 2000>  _ehSpotCoordGeoRight_type;
  _ehSpotCoordGeoRight_type ehSpotCoordGeoRight;

   typedef  ::std_msgs::UInt16_<ContainerAllocator>  _NbrSpotCoordGeoRight_type;
  _NbrSpotCoordGeoRight_type NbrSpotCoordGeoRight;

   typedef boost::array< ::project_s_msgs::ehSpotCoordGeo_<ContainerAllocator> , 2000>  _ehSpotCoordGeoLeft_type;
  _ehSpotCoordGeoLeft_type ehSpotCoordGeoLeft;

   typedef  ::std_msgs::UInt16_<ContainerAllocator>  _NbrSpotCoordGeoLeft_type;
  _NbrSpotCoordGeoLeft_type NbrSpotCoordGeoLeft;

   typedef boost::array< ::project_s_msgs::ehLineCoordGeo_<ContainerAllocator> , 10>  _ehLineCoordGeo_type;
  _ehLineCoordGeo_type ehLineCoordGeo;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _QtyLineCoordGeo_type;
  _QtyLineCoordGeo_type QtyLineCoordGeo;

   typedef boost::array< ::project_s_msgs::ehME_<ContainerAllocator> , 2>  _ehME_type;
  _ehME_type ehME;

   typedef boost::array< ::project_s_msgs::ehNbrLineCoordGeo_<ContainerAllocator> , 100>  _ehNbrLineCoordGeo_type;
  _ehNbrLineCoordGeo_type ehNbrLineCoordGeo;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _QtyNbrLineCoordGeo_type;
  _QtyNbrLineCoordGeo_type QtyNbrLineCoordGeo;

   typedef boost::array< ::project_s_msgs::ehSpotTrafficSign_<ContainerAllocator> , 50>  _ehSpotTrafficSign_type;
  _ehSpotTrafficSign_type ehSpotTrafficSign;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _NbrSpotTrafficSign_type;
  _NbrSpotTrafficSign_type NbrSpotTrafficSign;

   typedef  ::project_s_msgs::ehPosition_<ContainerAllocator>  _ehPosition_type;
  _ehPosition_type ehPosition;

   typedef uint8_t _speedLimit_interpolMethod_type;
  _speedLimit_interpolMethod_type speedLimit_interpolMethod;

   typedef uint8_t _curvature_interpolMethod_type;
  _curvature_interpolMethod_type curvature_interpolMethod;

   typedef boost::array< ::project_s_msgs::ehSegmentME_<ContainerAllocator> , 100>  _ehSegmentAO_type;
  _ehSegmentAO_type ehSegmentAO;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _QtySegmentAO_type;
  _QtySegmentAO_type QtySegmentAO;

   typedef boost::array< ::project_s_msgs::ehSegmentME_<ContainerAllocator> , 100>  _ehSegmentEO_type;
  _ehSegmentEO_type ehSegmentEO;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _QtySegmentEO_type;
  _QtySegmentEO_type QtySegmentEO;



  enum {
    SEGMENT_REPORT_SIZE = 50u,
    STUB_REPORT_SIZE = 10u,
    SPOT_CURVATURE_REPORT_SIZE = 300u,
    SPOT_COORD_GEO_REPORT_SIZE = 2000u,
    LINE_REPORT_SIZE = 10u,
    ME_RIGHT_LINE = 0u,
    ME_LEFT_LINE = 1u,
    NBR_LINE_REPORT_SIZE = 100u,
    SPOT_TRAFFIC_SIGN_REPORT_SIZE = 50u,
    STEP = 0u,
    LINEAR = 1u,
    SEGMENT_ARRET_OBSTACLE_REPORT_SIZE = 100u,
    SEGMENT_EVITEMENT_OBSTACLE_REPORT_SIZE = 100u,
  };


  typedef boost::shared_ptr< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> const> ConstPtr;

}; // struct ElectronicHorizon_

typedef ::project_s_msgs::ElectronicHorizon_<std::allocator<void> > ElectronicHorizon;

typedef boost::shared_ptr< ::project_s_msgs::ElectronicHorizon > ElectronicHorizonPtr;
typedef boost::shared_ptr< ::project_s_msgs::ElectronicHorizon const> ElectronicHorizonConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace project_s_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'nav_msgs': ['/opt/ros/kinetic/share/nav_msgs/cmake/../msg'], 'shape_msgs': ['/opt/ros/kinetic/share/shape_msgs/cmake/../msg'], 'sensor_msgs': ['/opt/ros/kinetic/share/sensor_msgs/cmake/../msg'], 'actionlib_msgs': ['/opt/ros/kinetic/share/actionlib_msgs/cmake/../msg'], 'trajectory_msgs': ['/opt/ros/kinetic/share/trajectory_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'project_s_msgs': ['/home/segula/Desktop/ava/achitecture_ws/src/project_s_msgs/msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'mobileye_560_660_msgs': ['/home/dev/as_drivers_customer/install/share/mobileye_560_660_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3734a37717a8e474a926575905e89801";
  }

  static const char* value(const ::project_s_msgs::ElectronicHorizon_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3734a37717a8e474ULL;
  static const uint64_t static_value2 = 0xa926575905e89801ULL;
};

template<class ContainerAllocator>
struct DataType< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
{
  static const char* value()
  {
    return "project_s_msgs/ElectronicHorizon";
  }

  static const char* value(const ::project_s_msgs::ElectronicHorizon_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
std_msgs/UInt8 id\n\
\n\
std_msgs/UInt8 indexPath\n\
\n\
uint8 SEGMENT_REPORT_SIZE = 50\n\
project_s_msgs/ehSegment[50] ehSegment\n\
std_msgs/UInt8 NbrSegment\n\
\n\
uint8 STUB_REPORT_SIZE = 10\n\
project_s_msgs/ehStub[10] ehStub\n\
std_msgs/UInt8 NbrStub\n\
\n\
uint16 SPOT_CURVATURE_REPORT_SIZE = 300\n\
project_s_msgs/ehSpotCurvature[300] ehSpotCurvature\n\
std_msgs/UInt16 NbrSpotCurvature\n\
\n\
uint16 SPOT_COORD_GEO_REPORT_SIZE = 2000\n\
project_s_msgs/ehSpotCoordGeo[2000] ehSpotCoordGeoRight\n\
std_msgs/UInt16 NbrSpotCoordGeoRight\n\
project_s_msgs/ehSpotCoordGeo[2000] ehSpotCoordGeoLeft\n\
std_msgs/UInt16 NbrSpotCoordGeoLeft\n\
\n\
uint8 LINE_REPORT_SIZE = 10\n\
project_s_msgs/ehLineCoordGeo[10] ehLineCoordGeo\n\
std_msgs/UInt8 QtyLineCoordGeo\n\
\n\
uint8 ME_RIGHT_LINE = 0\n\
uint8 ME_LEFT_LINE = 1\n\
project_s_msgs/ehME[2] ehME\n\
\n\
uint8 NBR_LINE_REPORT_SIZE = 100\n\
project_s_msgs/ehNbrLineCoordGeo[100] ehNbrLineCoordGeo\n\
std_msgs/UInt8 QtyNbrLineCoordGeo\n\
\n\
uint8 SPOT_TRAFFIC_SIGN_REPORT_SIZE = 50\n\
project_s_msgs/ehSpotTrafficSign[50] ehSpotTrafficSign\n\
std_msgs/UInt8 NbrSpotTrafficSign\n\
\n\
project_s_msgs/ehPosition ehPosition\n\
\n\
uint8 speedLimit_interpolMethod\n\
uint8 curvature_interpolMethod\n\
uint8 STEP = 0\n\
uint8 LINEAR = 1\n\
\n\
uint8 SEGMENT_ARRET_OBSTACLE_REPORT_SIZE = 100\n\
project_s_msgs/ehSegmentME[100] ehSegmentAO\n\
std_msgs/UInt8 QtySegmentAO\n\
\n\
uint8 SEGMENT_EVITEMENT_OBSTACLE_REPORT_SIZE = 100\n\
project_s_msgs/ehSegmentME[100] ehSegmentEO\n\
std_msgs/UInt8 QtySegmentEO\n\
\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: std_msgs/UInt8\n\
uint8 data\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehSegment\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
#std_msgs/UInt8 indexPath\n\
std_msgs/Float32 offset\n\
std_msgs/UInt8 functionRoadClass\n\
std_msgs/UInt8 wayForm\n\
std_msgs/UInt8 effectiveSpeedLimit\n\
std_msgs/UInt8 nbLanesDrivingDirection\n\
std_msgs/UInt8 nbLanesOppositeDirection\n\
\n\
\n\
\n\
================================================================================\n\
MSG: std_msgs/Float32\n\
float32 data\n\
================================================================================\n\
MSG: project_s_msgs/ehStub\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
#std_msgs/UInt8 indexPath\n\
std_msgs/Float32 offset\n\
std_msgs/UInt8 indexSubPath\n\
std_msgs/Float32 turnAngle\n\
std_msgs/UInt8 functionRoadClass\n\
std_msgs/UInt8 wayForm\n\
std_msgs/UInt8 nbLanesDrivingDirection\n\
std_msgs/UInt8 nbLanesOppositeDirection\n\
\n\
\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehSpotCurvature\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
#std_msgs/UInt8 indexPath\n\
std_msgs/Float32 offset\n\
std_msgs/Float32 Value_0\n\
std_msgs/Float32 Distance_1\n\
std_msgs/Float32 Value_1\n\
\n\
\n\
\n\
================================================================================\n\
MSG: std_msgs/UInt16\n\
uint16 data\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehSpotCoordGeo\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
std_msgs/Float32 offset\n\
float64 latitude\n\
float64 longitude\n\
\n\
\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehLineCoordGeo\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
uint32 SPOT_REPORT_SIZE = 3000\n\
project_s_msgs/ehSpotCoordGeo[3000] ehSpotCoordGeo\n\
std_msgs/UInt32 NbrSpotCoordGeo\n\
\n\
\n\
================================================================================\n\
MSG: std_msgs/UInt32\n\
uint32 data\n\
================================================================================\n\
MSG: project_s_msgs/ehME\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
uint32 SPOT_REPORT_SIZE = 2000\n\
project_s_msgs/ehSpotCoordGeo[2000] ehSpotCoordGeo\n\
std_msgs/UInt32 NbrSpotCoordGeo\n\
\n\
uint32 SEGMENT_ME_REPORT_SIZE = 100\n\
project_s_msgs/ehSegmentME[100] ehSegmentME\n\
std_msgs/UInt32 QtySegment\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehSegmentME\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
std_msgs/UInt32 NbrSpot\n\
std_msgs/Float32 offset_debut\n\
std_msgs/Float32 offset_fin\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehNbrLineCoordGeo\n\
std_msgs/UInt8 Nbr\n\
std_msgs/Float32 offset\n\
\n\
\n\
\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehSpotTrafficSign\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
std_msgs/Float32 offset\n\
uint8 Sign_Type\n\
uint8 Value\n\
uint8 Lane\n\
uint8 Sign_Location\n\
float64 latitude\n\
float64 longitude\n\
\n\
\n\
\n\
\n\
================================================================================\n\
MSG: project_s_msgs/ehPosition\n\
Header header\n\
std_msgs/UInt8 id\n\
\n\
#std_msgs/UInt8 indexPath\n\
std_msgs/Float32 offset\n\
float64 latitude\n\
float64 longitude\n\
std_msgs/Float32 cap\n\
std_msgs/UInt16 agePosition\n\
std_msgs/Float32 speed\n\
std_msgs/Float32 relativeHeading\n\
std_msgs/UInt8 currentLane\n\
\n\
\n\
";
  }

  static const char* value(const ::project_s_msgs::ElectronicHorizon_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.id);
      stream.next(m.indexPath);
      stream.next(m.ehSegment);
      stream.next(m.NbrSegment);
      stream.next(m.ehStub);
      stream.next(m.NbrStub);
      stream.next(m.ehSpotCurvature);
      stream.next(m.NbrSpotCurvature);
      stream.next(m.ehSpotCoordGeoRight);
      stream.next(m.NbrSpotCoordGeoRight);
      stream.next(m.ehSpotCoordGeoLeft);
      stream.next(m.NbrSpotCoordGeoLeft);
      stream.next(m.ehLineCoordGeo);
      stream.next(m.QtyLineCoordGeo);
      stream.next(m.ehME);
      stream.next(m.ehNbrLineCoordGeo);
      stream.next(m.QtyNbrLineCoordGeo);
      stream.next(m.ehSpotTrafficSign);
      stream.next(m.NbrSpotTrafficSign);
      stream.next(m.ehPosition);
      stream.next(m.speedLimit_interpolMethod);
      stream.next(m.curvature_interpolMethod);
      stream.next(m.ehSegmentAO);
      stream.next(m.QtySegmentAO);
      stream.next(m.ehSegmentEO);
      stream.next(m.QtySegmentEO);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ElectronicHorizon_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::project_s_msgs::ElectronicHorizon_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::project_s_msgs::ElectronicHorizon_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "id: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.id);
    s << indent << "indexPath: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.indexPath);
    s << indent << "ehSegment[]" << std::endl;
    for (size_t i = 0; i < v.ehSegment.size(); ++i)
    {
      s << indent << "  ehSegment[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSegment_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSegment[i]);
    }
    s << indent << "NbrSegment: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.NbrSegment);
    s << indent << "ehStub[]" << std::endl;
    for (size_t i = 0; i < v.ehStub.size(); ++i)
    {
      s << indent << "  ehStub[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehStub_<ContainerAllocator> >::stream(s, indent + "    ", v.ehStub[i]);
    }
    s << indent << "NbrStub: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.NbrStub);
    s << indent << "ehSpotCurvature[]" << std::endl;
    for (size_t i = 0; i < v.ehSpotCurvature.size(); ++i)
    {
      s << indent << "  ehSpotCurvature[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSpotCurvature_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSpotCurvature[i]);
    }
    s << indent << "NbrSpotCurvature: ";
    s << std::endl;
    Printer< ::std_msgs::UInt16_<ContainerAllocator> >::stream(s, indent + "  ", v.NbrSpotCurvature);
    s << indent << "ehSpotCoordGeoRight[]" << std::endl;
    for (size_t i = 0; i < v.ehSpotCoordGeoRight.size(); ++i)
    {
      s << indent << "  ehSpotCoordGeoRight[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSpotCoordGeo_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSpotCoordGeoRight[i]);
    }
    s << indent << "NbrSpotCoordGeoRight: ";
    s << std::endl;
    Printer< ::std_msgs::UInt16_<ContainerAllocator> >::stream(s, indent + "  ", v.NbrSpotCoordGeoRight);
    s << indent << "ehSpotCoordGeoLeft[]" << std::endl;
    for (size_t i = 0; i < v.ehSpotCoordGeoLeft.size(); ++i)
    {
      s << indent << "  ehSpotCoordGeoLeft[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSpotCoordGeo_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSpotCoordGeoLeft[i]);
    }
    s << indent << "NbrSpotCoordGeoLeft: ";
    s << std::endl;
    Printer< ::std_msgs::UInt16_<ContainerAllocator> >::stream(s, indent + "  ", v.NbrSpotCoordGeoLeft);
    s << indent << "ehLineCoordGeo[]" << std::endl;
    for (size_t i = 0; i < v.ehLineCoordGeo.size(); ++i)
    {
      s << indent << "  ehLineCoordGeo[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehLineCoordGeo_<ContainerAllocator> >::stream(s, indent + "    ", v.ehLineCoordGeo[i]);
    }
    s << indent << "QtyLineCoordGeo: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.QtyLineCoordGeo);
    s << indent << "ehME[]" << std::endl;
    for (size_t i = 0; i < v.ehME.size(); ++i)
    {
      s << indent << "  ehME[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehME_<ContainerAllocator> >::stream(s, indent + "    ", v.ehME[i]);
    }
    s << indent << "ehNbrLineCoordGeo[]" << std::endl;
    for (size_t i = 0; i < v.ehNbrLineCoordGeo.size(); ++i)
    {
      s << indent << "  ehNbrLineCoordGeo[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehNbrLineCoordGeo_<ContainerAllocator> >::stream(s, indent + "    ", v.ehNbrLineCoordGeo[i]);
    }
    s << indent << "QtyNbrLineCoordGeo: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.QtyNbrLineCoordGeo);
    s << indent << "ehSpotTrafficSign[]" << std::endl;
    for (size_t i = 0; i < v.ehSpotTrafficSign.size(); ++i)
    {
      s << indent << "  ehSpotTrafficSign[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSpotTrafficSign_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSpotTrafficSign[i]);
    }
    s << indent << "NbrSpotTrafficSign: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.NbrSpotTrafficSign);
    s << indent << "ehPosition: ";
    s << std::endl;
    Printer< ::project_s_msgs::ehPosition_<ContainerAllocator> >::stream(s, indent + "  ", v.ehPosition);
    s << indent << "speedLimit_interpolMethod: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.speedLimit_interpolMethod);
    s << indent << "curvature_interpolMethod: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.curvature_interpolMethod);
    s << indent << "ehSegmentAO[]" << std::endl;
    for (size_t i = 0; i < v.ehSegmentAO.size(); ++i)
    {
      s << indent << "  ehSegmentAO[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSegmentME_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSegmentAO[i]);
    }
    s << indent << "QtySegmentAO: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.QtySegmentAO);
    s << indent << "ehSegmentEO[]" << std::endl;
    for (size_t i = 0; i < v.ehSegmentEO.size(); ++i)
    {
      s << indent << "  ehSegmentEO[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::project_s_msgs::ehSegmentME_<ContainerAllocator> >::stream(s, indent + "    ", v.ehSegmentEO[i]);
    }
    s << indent << "QtySegmentEO: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.QtySegmentEO);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PROJECT_S_MSGS_MESSAGE_ELECTRONICHORIZON_H
